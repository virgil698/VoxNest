# VoxNest 插件开发指南

## 快速开始

### 环境准备
- .NET 9.0 SDK
- Visual Studio 2022 或 VS Code
- VoxNest Plugin SDK

### 创建插件项目
```bash
# 安装插件模板
dotnet new install VoxNest.Plugin.Templates

# 创建新插件
dotnet new voxnest-plugin -n MyBlogPlugin -o ./MyBlogPlugin

# 进入项目目录
cd MyBlogPlugin
```

### 项目结构
```
MyBlogPlugin/
├── MyBlogPlugin.csproj          # 项目文件
├── Plugin.cs                    # 插件主类
├── plugin.json                  # 插件元数据
├── Controllers/                 # API控制器
│   └── BlogController.cs
├── Services/                    # 业务服务
│   └── BlogService.cs
├── Models/                      # 数据模型
│   └── BlogPost.cs
├── Views/                       # 视图模板
├── wwwroot/                     # 静态资源
│   ├── js/
│   ├── css/
│   └── images/
└── README.md                    # 插件说明
```

## 插件基础开发

### 插件主类实现
```csharp
using VoxNest.Core.Plugins;
using Microsoft.Extensions.DependencyInjection;

[Plugin("blog-plugin", "1.0.0")]
public class BlogPlugin : IPlugin, IContentPlugin, IUIPlugin
{
    public string Id => "blog-plugin";
    public string Name => "博客插件";
    public string Version => "1.0.0";
    public string Description => "提供博客文章发布和管理功能";
    public string Author => "VoxNest Team";

    private IPluginContext _context;

    public async Task<bool> InitializeAsync(IPluginContext context)
    {
        _context = context;
        
        // 注册服务
        context.Services.AddScoped<IBlogService, BlogService>();
        context.Services.AddScoped<BlogController>();
        
        // 订阅事件
        context.EventBus.Subscribe<UserRegisteredEvent>(OnUserRegistered);
        
        return true;
    }

    public async Task<bool> StartAsync()
    {
        _context.Logger.LogInformation("博客插件已启动");
        return true;
    }

    public async Task<bool> StopAsync()
    {
        _context.Logger.LogInformation("博客插件已停止");
        return true;
    }

    public async Task<bool> UnloadAsync()
    {
        // 清理资源
        return true;
    }

    private async Task OnUserRegistered(UserRegisteredEvent eventData)
    {
        // 为新用户创建默认博客设置
        var blogService = _context.GetService<IBlogService>();
        await blogService.CreateDefaultSettingsAsync(eventData.UserId);
    }
}
```

### 插件元数据配置
```json
{
  "id": "blog-plugin",
  "name": "博客插件",
  "version": "1.0.0",
  "description": "提供博客文章发布和管理功能",
  "author": "VoxNest Team",
  "homepage": "https://github.com/voxnest/blog-plugin",
  "license": "MIT",
  "keywords": ["blog", "content", "writing"],
  
  "dependencies": {
    "voxnest-core": ">=1.0.0",
    "content-plugin": ">=1.0.0"
  },
  
  "permissions": [
    "content.create",
    "content.edit",
    "content.delete",
    "file.upload"
  ],
  
  "configuration": {
    "maxPostLength": {
      "type": "integer",
      "default": 50000,
      "description": "文章最大长度"
    },
    "allowComments": {
      "type": "boolean",
      "default": true,
      "description": "是否允许评论"
    }
  },
  
  "routes": [
    {
      "path": "/blog",
      "component": "BlogList"
    },
    {
      "path": "/blog/post/:id",
      "component": "BlogPost"
    },
    {
      "path": "/blog/create",
      "component": "CreatePost",
      "requireAuth": true
    }
  ],
  
  "menus": [
    {
      "title": "博客",
      "icon": "blog",
      "path": "/blog",
      "order": 10
    }
  ]
}
```

## 内容插件开发

### 实现内容插件接口
```csharp
public class BlogPlugin : IContentPlugin
{
    public string ContentType => "blog-post";

    public async Task<ContentResult> CreateContentAsync(CreateContentRequest request)
    {
        var blogPost = new BlogPost
        {
            Title = request.Title,
            Content = request.Body,
            AuthorId = request.AuthorId,
            Tags = request.Metadata.GetValueOrDefault("tags", "").Split(','),
            Category = request.Metadata.GetValueOrDefault("category", ""),
            CreatedAt = DateTime.UtcNow
        };

        var blogService = _context.GetService<IBlogService>();
        var result = await blogService.CreatePostAsync(blogPost);

        return new ContentResult
        {
            Success = result.Success,
            ContentId = result.PostId,
            Message = result.Message
        };
    }

    public async Task<ContentResult> UpdateContentAsync(UpdateContentRequest request)
    {
        var blogService = _context.GetService<IBlogService>();
        var result = await blogService.UpdatePostAsync(request.ContentId, request);

        return new ContentResult
        {
            Success = result.Success,
            Message = result.Message
        };
    }

    public async Task<ContentListResult> GetContentListAsync(GetContentListRequest request)
    {
        var blogService = _context.GetService<IBlogService>();
        var posts = await blogService.GetPostsAsync(request.Page, request.PageSize, request.Filters);

        return new ContentListResult
        {
            Items = posts.Items.Select(p => new ContentItem
            {
                Id = p.Id,
                Title = p.Title,
                Summary = p.Summary,
                AuthorId = p.AuthorId,
                CreatedAt = p.CreatedAt
            }).ToList(),
            TotalCount = posts.TotalCount,
            Page = request.Page,
            PageSize = request.PageSize
        };
    }
}
```

## 前端扩展开发

### 创建前端扩展项目

```bash
# 在 public/extensions/plugins/ 目录下创建新扩展
mkdir -p public/extensions/plugins/my-plugin
cd public/extensions/plugins/my-plugin

# 创建扩展清单
cat > manifest.json << EOF
{
  "id": "my-plugin",
  "name": "我的插件",
  "version": "1.0.0",
  "author": "Your Name",
  "description": "一个示例扩展插件",
  "type": "plugin",
  "entry": "index.js",
  "styles": ["styles.css"],
  "config": {
    "title": "我的插件",
    "enabled": true
  }
}
EOF
```

### 扩展入口文件开发

```typescript
// index.js
import { createComponentIntegration } from '@voxnest/extension-framework';
import { MyComponent } from './components/MyComponent';
import { MyHeaderWidget } from './components/MyHeaderWidget';

// 创建组件集成
export default createComponentIntegration(
  'my-plugin',
  [
    {
      slotId: 'layout:header.right',
      component: MyHeaderWidget,
      priority: 10,
    },
    {
      slotId: 'layout:sidebar.top',
      component: MyComponent,
      priority: 5,
    }
  ]
);

// 或者创建完整的集成
export const myAdvancedIntegration = {
  name: 'my-plugin:advanced',
  hooks: {
    'framework:ready': (context) => {
      context.logger.info('My plugin framework ready');
      // 注册服务或执行初始化
    },
    
    'components:ready': (context) => {
      // 注册组件到槽位
      context.slots.register('layout:content.after', {
        component: MyFooterComponent,
        source: 'my-plugin',
        priority: 0,
        condition: (props) => props.showFooter !== false
      });
    },
    
    'app:started': (context) => {
      context.logger.info('My plugin: App started');
      // 执行应用启动后的逻辑
    }
  }
};
```

### React 组件开发

```tsx
// components/MyHeaderWidget.tsx
import React, { useState } from 'react';
import { useExtensionContext } from '@voxnest/extension-framework';

export const MyHeaderWidget: React.FC = () => {
  const { logger, config } = useExtensionContext();
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(c => c + 1);
    logger.info(`Button clicked ${count + 1} times`);
  };

  return (
    <div className="my-header-widget">
      <button onClick={handleClick} className="widget-button">
        {config.title || 'Widget'} ({count})
      </button>
    </div>
  );
};

// components/MyComponent.tsx  
import React, { useEffect } from 'react';
import { useExtensionContext } from '@voxnest/extension-framework';

interface MyComponentProps {
  title?: string;
  children?: React.ReactNode;
}

export const MyComponent: React.FC<MyComponentProps> = ({ 
  title = 'Default Title',
  children 
}) => {
  const { logger, framework } = useExtensionContext();

  useEffect(() => {
    logger.debug('MyComponent mounted');
    
    return () => {
      logger.debug('MyComponent unmounted');  
    };
  }, [logger]);

  return (
    <div className="my-component">
      <h3>{title}</h3>
      <div className="component-content">
        {children || <p>这是我的自定义组件内容</p>}
      </div>
      <div className="component-info">
        <small>插件状态: {framework.status}</small>
      </div>
    </div>
  );
};
```

### 使用扩展框架 Hook

```tsx
// hooks/useMyPlugin.ts
import { useCallback, useEffect, useState } from 'react';
import { useExtensionContext } from '@voxnest/extension-framework';

export function useMyPlugin() {
  const { config, logger, framework } = useExtensionContext();
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);

  const loadData = useCallback(async () => {
    setLoading(true);
    try {
      // 模拟API调用
      const response = await fetch('/api/my-plugin/data');
      const result = await response.json();
      setData(result);
      logger.info('Data loaded successfully', result);
    } catch (error) {
      logger.error('Failed to load data', error);
    } finally {
      setLoading(false);
    }
  }, [logger]);

  const saveData = useCallback(async (newData: any) => {
    try {
      await fetch('/api/my-plugin/data', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newData)
      });
      setData(newData);
      logger.info('Data saved successfully');
    } catch (error) {
      logger.error('Failed to save data', error);
      throw error;
    }
  }, [logger]);

  return {
    data,
    loading,
    loadData,
    saveData,
    config,
    pluginEnabled: config.enabled,
    frameworkReady: framework.status === 'ready'
  };
}
```

### 扩展样式开发

```css
/* styles.css */
.my-header-widget {
  display: flex;
  align-items: center;
  gap: 8px;
}

.widget-button {
  padding: 4px 12px;
  border: 1px solid var(--voxnest-border);
  border-radius: var(--voxnest-radius);
  background: var(--voxnest-bg);
  color: var(--voxnest-text);
  cursor: pointer;
  transition: all 0.2s ease;
}

.widget-button:hover {
  background: var(--voxnest-primary);
  color: white;
  border-color: var(--voxnest-primary);
}

.my-component {
  padding: 16px;
  border: 1px solid var(--voxnest-border);
  border-radius: var(--voxnest-radius);
  background: var(--voxnest-bg);
  margin-bottom: 16px;
}

.my-component h3 {
  margin: 0 0 12px 0;
  color: var(--voxnest-primary);
  font-size: 16px;
  font-weight: 600;
}

.component-content {
  margin-bottom: 12px;
  line-height: 1.5;
}

.component-info {
  padding-top: 8px;
  border-top: 1px solid var(--voxnest-border);
  color: var(--voxnest-text);
  opacity: 0.7;
}

/* 深色主题适配 */
[data-theme="dark"] .widget-button {
  background: var(--voxnest-card-bg, #2a2a2a);
  border-color: var(--voxnest-border, #333333);
}

/* 响应式设计 */
@media (max-width: 768px) {
  .my-component {
    padding: 12px;
    margin-bottom: 12px;
  }
  
  .widget-button {
    padding: 3px 8px;
    font-size: 12px;
  }
}
```

### 高级集成开发

```typescript
// advanced-integration.ts
import type { Integration, IntegrationContext } from '@voxnest/extension-framework';
import { MyDataService } from './services/MyDataService';
import { MyEventHandler } from './handlers/MyEventHandler';

export function createAdvancedIntegration(): Integration {
  let dataService: MyDataService;
  let eventHandler: MyEventHandler;
  
  return {
    name: 'my-plugin:advanced',
    hooks: {
      'framework:ready': async (context: IntegrationContext) => {
        context.logger.info('Advanced integration: Framework ready');
        
        // 初始化服务
        dataService = new MyDataService(context.config);
        eventHandler = new MyEventHandler(context.logger);
        
        // 设置全局错误处理
        window.addEventListener('error', (event) => {
          context.logger.error('Global error caught', event.error);
        });
      },

      'components:ready': async (context: IntegrationContext) => {
        context.logger.info('Advanced integration: Components ready');
        
        // 动态注册组件
        const components = await dataService.getAvailableComponents();
        
        components.forEach(comp => {
          context.slots.register(comp.slotId, {
            component: comp.component,
            source: 'my-plugin:advanced',
            priority: comp.priority,
            condition: comp.condition
          });
        });
      },

      'app:start': async (context: IntegrationContext) => {
        // 预加载数据
        await dataService.preloadData();
        
        // 注册事件监听器
        eventHandler.setupEventListeners(context.framework);
      },

      'app:started': (context: IntegrationContext) => {
        context.logger.info('Advanced integration: App started');
        
        // 应用启动完成后的处理
        dataService.startBackgroundTasks();
      },

      'app:destroy': async (context: IntegrationContext) => {
        context.logger.info('Advanced integration: App destroying');
        
        // 清理资源
        eventHandler.cleanup();
        await dataService.cleanup();
      }
    }
  };
}

// services/MyDataService.ts
export class MyDataService {
  constructor(private config: any) {}
  
  async getAvailableComponents() {
    // 根据配置动态确定要注册的组件
    const components = [];
    
    if (this.config.enableFeatureA) {
      components.push({
        slotId: 'layout:sidebar.top',
        component: () => <div>Feature A Component</div>,
        priority: 10
      });
    }
    
    return components;
  }
  
  async preloadData() {
    // 预加载必要的数据
  }
  
  startBackgroundTasks() {
    // 启动后台任务
  }
  
  async cleanup() {
    // 清理资源
  }
}
```

## 主题扩展开发

### 创建主题扩展

```bash
# 在 public/extensions/themes/ 目录下创建新主题
mkdir -p public/extensions/themes/my-theme
cd public/extensions/themes/my-theme

# 创建主题清单
cat > manifest.json << EOF
{
  "id": "my-theme",
  "name": "我的主题",
  "version": "1.0.0",
  "author": "Your Name",
  "description": "一个自定义主题",
  "type": "theme",
  "styles": ["theme.css"],
  "config": {
    "variables": {
      "--voxnest-primary": "#6366f1",
      "--voxnest-bg": "#ffffff",
      "--voxnest-text": "#1f2937",
      "--voxnest-border": "#e5e7eb",
      "--voxnest-card-bg": "#f9fafb"
    },
    "colorScheme": {
      "primary": "#6366f1",
      "background": "#ffffff",
      "surface": "#f9fafb",
      "text": "#1f2937",
      "border": "#e5e7eb"
    }
  },
  "supportedModes": ["light", "dark"],
  "enabled": false
}
EOF
```

### 主题样式开发

```css
/* theme.css */
:root {
  /* 基础颜色变量 */
  --voxnest-primary: #6366f1;
  --voxnest-primary-dark: #4f46e5;
  --voxnest-primary-light: #8b5cf6;
  
  --voxnest-success: #10b981;
  --voxnest-warning: #f59e0b;
  --voxnest-error: #ef4444;
  
  /* 背景颜色 */
  --voxnest-bg: #ffffff;
  --voxnest-bg-secondary: #f9fafb;
  --voxnest-card-bg: #ffffff;
  
  /* 文本颜色 */
  --voxnest-text: #1f2937;
  --voxnest-text-secondary: #6b7280;
  --voxnest-text-muted: #9ca3af;
  
  /* 边框和分割线 */
  --voxnest-border: #e5e7eb;
  --voxnest-border-light: #f3f4f6;
  
  /* 阴影 */
  --voxnest-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
  --voxnest-shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  
  /* 圆角 */
  --voxnest-radius: 6px;
  --voxnest-radius-lg: 12px;
  
  /* 间距 */
  --voxnest-spacing-xs: 4px;
  --voxnest-spacing-sm: 8px;
  --voxnest-spacing-md: 16px;
  --voxnest-spacing-lg: 24px;
  --voxnest-spacing-xl: 32px;
}

/* 深色模式 */
[data-theme="dark"] {
  --voxnest-primary: #8b5cf6;
  --voxnest-primary-dark: #7c3aed;
  --voxnest-primary-light: #a78bfa;
  
  --voxnest-success: #34d399;
  --voxnest-warning: #fbbf24;
  --voxnest-error: #f87171;
  
  --voxnest-bg: #111827;
  --voxnest-bg-secondary: #1f2937;
  --voxnest-card-bg: #1f2937;
  
  --voxnest-text: #f9fafb;
  --voxnest-text-secondary: #d1d5db;
  --voxnest-text-muted: #9ca3af;
  
  --voxnest-border: #374151;
  --voxnest-border-light: #4b5563;
  
  --voxnest-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 2px 0 rgba(0, 0, 0, 0.2);
  --voxnest-shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2);
}

/* 组件样式 */
.voxnest-button {
  background: var(--voxnest-primary);
  color: white;
  border: none;
  border-radius: var(--voxnest-radius);
  padding: var(--voxnest-spacing-sm) var(--voxnest-spacing-md);
  cursor: pointer;
  transition: all 0.2s ease;
}

.voxnest-button:hover {
  background: var(--voxnest-primary-dark);
  transform: translateY(-1px);
  box-shadow: var(--voxnest-shadow);
}

.voxnest-card {
  background: var(--voxnest-card-bg);
  border: 1px solid var(--voxnest-border);
  border-radius: var(--voxnest-radius-lg);
  padding: var(--voxnest-spacing-lg);
  box-shadow: var(--voxnest-shadow);
  transition: all 0.2s ease;
}

.voxnest-card:hover {
  box-shadow: var(--voxnest-shadow-lg);
  transform: translateY(-2px);
}

.voxnest-input {
  background: var(--voxnest-bg);
  border: 1px solid var(--voxnest-border);
  border-radius: var(--voxnest-radius);
  padding: var(--voxnest-spacing-sm) var(--voxnest-spacing-md);
  color: var(--voxnest-text);
  transition: border-color 0.2s ease;
}

.voxnest-input:focus {
  outline: none;
  border-color: var(--voxnest-primary);
  box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
}

/* 动画 */
@keyframes voxnest-fade-in {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.voxnest-fade-in {
  animation: voxnest-fade-in 0.3s ease-out;
}

/* 响应式设计 */
@media (max-width: 768px) {
  :root {
    --voxnest-spacing-md: 12px;
    --voxnest-spacing-lg: 16px;
    --voxnest-spacing-xl: 24px;
  }
}

/* 高对比度模式支持 */
@media (prefers-contrast: high) {
  :root {
    --voxnest-border: #000000;
    --voxnest-text: #000000;
  }
  
  [data-theme="dark"] {
    --voxnest-border: #ffffff;
    --voxnest-text: #ffffff;
  }
}

/* 减少动画模式支持 */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
```

### 主题配置集成

```typescript
// theme-integration.ts
import type { Integration, IntegrationContext } from '@voxnest/extension-framework';

export function createThemeIntegration(themeConfig: any): Integration {
  return {
    name: 'my-theme',
    hooks: {
      'framework:ready': (context: IntegrationContext) => {
        context.logger.info('Theme integration: Framework ready');
        
        // 应用主题变量
        if (themeConfig.variables) {
          applyThemeVariables(themeConfig.variables);
        }
        
        // 设置主题模式切换
        setupThemeModeToggle(context);
      },

      'app:started': (context: IntegrationContext) => {
        // 主题启动后处理
        context.logger.info('Theme applied successfully');
        
        // 可以发送主题应用事件
        if (typeof window !== 'undefined') {
          window.dispatchEvent(new CustomEvent('theme:applied', {
            detail: { themeId: 'my-theme', config: themeConfig }
          }));
        }
      }
    }
  };
}

function applyThemeVariables(variables: Record<string, string>) {
  if (typeof document === 'undefined') return;
  
  const root = document.documentElement;
  
  Object.entries(variables).forEach(([name, value]) => {
    const cssVarName = name.startsWith('--') ? name : `--${name}`;
    root.style.setProperty(cssVarName, value);
  });
}

function setupThemeModeToggle(context: IntegrationContext) {
  if (typeof window === 'undefined') return;
  
  // 监听主题模式切换
  window.addEventListener('theme:toggle', (event: any) => {
    const mode = event.detail?.mode || 'light';
    document.documentElement.setAttribute('data-theme', mode);
    context.logger.info(`Theme mode switched to: ${mode}`);
  });
  
  // 检测系统主题偏好
  const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
  const handleChange = (e: MediaQueryListEvent) => {
    if (!document.documentElement.hasAttribute('data-theme-override')) {
      const mode = e.matches ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', mode);
    }
  };
  
  mediaQuery.addEventListener('change', handleChange);
  handleChange(mediaQuery as any);
}
```

## 扩展测试与调试

### 开发工具使用

```typescript
// 启用开发模式
const framework = createExtensionFramework({
  logLevel: 'debug',
  dev: true, // 启用开发模式
});

// 开发模式下可用的调试工具
if (process.env.NODE_ENV === 'development') {
  // 全局访问框架实例
  (window as any).__VOXNEST_FRAMEWORK__ = framework;
  
  // 调试函数
  (window as any).__DEBUG__ = {
    getFrameworkStats: () => framework.getStats(),
    listSlots: () => {
      const slots = framework.slots;
      // 返回所有槽位信息
    },
    listIntegrations: () => framework.integrations.getAll(),
    reloadExtension: async (extensionId: string) => {
      // 重新加载扩展的逻辑
    }
  };
}
```

### 扩展单元测试

```typescript
// __tests__/my-plugin.test.ts
import { render, screen } from '@testing-library/react';
import { ExtensionProvider } from '@voxnest/extension-framework';
import { MyHeaderWidget } from '../components/MyHeaderWidget';

describe('MyHeaderWidget', () => {
  it('renders correctly', () => {
    const mockConfig = {
      title: 'Test Widget',
      enabled: true
    };

    render(
      <ExtensionProvider config={{ dev: true }}>
        <MyHeaderWidget />
      </ExtensionProvider>
    );

    expect(screen.getByText(/Test Widget/)).toBeInTheDocument();
  });

  it('handles click events', async () => {
    const { user } = render(
      <ExtensionProvider config={{ dev: true }}>
        <MyHeaderWidget />
      </ExtensionProvider>
    );

    const button = screen.getByRole('button');
    await user.click(button);

    expect(screen.getByText(/1/)).toBeInTheDocument();
  });
});

// __tests__/integration.test.ts
import { createExtensionFramework } from '@voxnest/extension-framework';
import { createAdvancedIntegration } from '../advanced-integration';

describe('Advanced Integration', () => {
  let framework: any;

  beforeEach(async () => {
    framework = createExtensionFramework({
      logLevel: 'silent',
      autoRegisterBuiltins: false
    });
    
    await framework.initialize();
  });

  afterEach(async () => {
    await framework.destroy();
  });

  it('registers integration successfully', () => {
    const integration = createAdvancedIntegration();
    
    expect(() => {
      framework.register(integration);
    }).not.toThrow();

    const registeredIntegration = framework.integrations.get('my-plugin:advanced');
    expect(registeredIntegration).toBeDefined();
    expect(registeredIntegration.name).toBe('my-plugin:advanced');
  });

  it('executes hooks correctly', async () => {
    const integration = createAdvancedIntegration();
    framework.register(integration);

    // 模拟钩子执行
    const context = {
      framework,
      config: { enableFeatureA: true },
      logger: { info: jest.fn(), debug: jest.fn(), error: jest.fn() },
      slots: { register: jest.fn() }
    };

    if (integration.hooks?.['framework:ready']) {
      await integration.hooks['framework:ready'](context);
    }

    expect(context.logger.info).toHaveBeenCalledWith('Advanced integration: Framework ready');
  });
});
```

### 性能分析

```typescript
// performance-monitor.ts
export class ExtensionPerformanceMonitor {
  private metrics = new Map<string, any>();

  startTiming(label: string) {
    this.metrics.set(label, { startTime: performance.now() });
  }

  endTiming(label: string) {
    const metric = this.metrics.get(label);
    if (metric) {
      metric.endTime = performance.now();
      metric.duration = metric.endTime - metric.startTime;
      console.log(`${label}: ${metric.duration.toFixed(2)}ms`);
    }
  }

  measureExtensionLoad(extensionId: string, loadFn: () => Promise<any>) {
    return new Promise(async (resolve, reject) => {
      this.startTiming(`load-${extensionId}`);
      
      try {
        const result = await loadFn();
        this.endTiming(`load-${extensionId}`);
        resolve(result);
      } catch (error) {
        this.endTiming(`load-${extensionId}`);
        reject(error);
      }
    });
  }

  getMetrics() {
    return Array.from(this.metrics.entries()).map(([label, metric]) => ({
      label,
      duration: metric.duration || 0,
      status: metric.duration ? 'completed' : 'pending'
    }));
  }
}

// 使用示例
const monitor = new ExtensionPerformanceMonitor();

// 在扩展加载时使用
await monitor.measureExtensionLoad('my-plugin', async () => {
  return await extensionLoader.loadPlugin(pluginManifest);
});

// 查看性能指标
console.table(monitor.getMetrics());
```

## 扩展发布与分发

### 扩展打包

```bash
#!/bin/bash
# build-extension.sh

EXTENSION_NAME=$1
EXTENSION_TYPE=$2  # plugin 或 theme

if [ -z "$EXTENSION_NAME" ] || [ -z "$EXTENSION_TYPE" ]; then
  echo "Usage: $0 <extension-name> <plugin|theme>"
  exit 1
fi

EXTENSION_DIR="public/extensions/${EXTENSION_TYPE}s/${EXTENSION_NAME}"
BUILD_DIR="dist/extensions/${EXTENSION_TYPE}s/${EXTENSION_NAME}"

# 检查扩展目录是否存在
if [ ! -d "$EXTENSION_DIR" ]; then
  echo "Error: Extension directory $EXTENSION_DIR does not exist"
  exit 1
fi

# 创建构建目录
mkdir -p "$BUILD_DIR"

# 复制文件
cp -r "$EXTENSION_DIR"/* "$BUILD_DIR"/

# 验证清单文件
if [ ! -f "$BUILD_DIR/manifest.json" ]; then
  echo "Error: manifest.json not found"
  exit 1
fi

# 压缩CSS（如果存在）
if command -v cssnano &> /dev/null; then
  find "$BUILD_DIR" -name "*.css" -exec cssnano {} {} \;
fi

# 压缩JS（如果存在）
if command -v terser &> /dev/null; then
  find "$BUILD_DIR" -name "*.js" -exec terser {} -o {} \;
fi

# 创建扩展包
cd "dist/extensions/${EXTENSION_TYPE}s"
tar -czf "${EXTENSION_NAME}.tar.gz" "$EXTENSION_NAME"

echo "Extension packaged successfully: dist/extensions/${EXTENSION_TYPE}s/${EXTENSION_NAME}.tar.gz"
```

### 插件路由注册
```typescript
// src/index.ts
import { PluginModule } from '@voxnest/plugin-sdk';
import { BlogList } from './components/BlogList';
import { BlogPost } from './components/BlogPost';
import { CreatePost } from './components/CreatePost';

const plugin: PluginModule = {
  id: 'blog-plugin',
  name: '博客插件',
  version: '1.0.0',
  
  routes: [
    {
      path: '/blog',
      component: BlogList,
      exact: true
    },
    {
      path: '/blog/post/:id',
      component: BlogPost
    },
    {
      path: '/blog/create',
      component: CreatePost,
      requireAuth: true
    }
  ],
  
  menus: [
    {
      key: 'blog',
      title: '博客',
      icon: 'edit',
      path: '/blog',
      order: 10
    }
  ],
  
  async initialize(context) {
    // 插件初始化逻辑
    console.log('博客插件已初始化');
  }
};

export default plugin;
```

## 数据库集成

### Entity Framework集成
```csharp
public class BlogDbContext : DbContext
{
    public DbSet<BlogPost> BlogPosts { get; set; }
    public DbSet<BlogCategory> BlogCategories { get; set; }
    public DbSet<BlogComment> BlogComments { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<BlogPost>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).HasMaxLength(500).IsRequired();
            entity.Property(e => e.Content).IsRequired();
            entity.Property(e => e.Summary).HasMaxLength(1000);
            
            entity.HasOne(e => e.Author)
                  .WithMany()
                  .HasForeignKey(e => e.AuthorId);
                  
            entity.HasOne(e => e.Category)
                  .WithMany(c => c.Posts)
                  .HasForeignKey(e => e.CategoryId);
        });
    }
}

// 在插件初始化时注册DbContext
public async Task<bool> InitializeAsync(IPluginContext context)
{
    context.Services.AddDbContext<BlogDbContext>(options =>
        options.UseNpgsql(context.Configuration.GetConnectionString("DefaultConnection")));
    
    // 自动迁移数据库
    using var scope = context.Services.CreateScope();
    var dbContext = scope.ServiceProvider.GetRequiredService<BlogDbContext>();
    await dbContext.Database.MigrateAsync();
    
    return true;
}
```

## 事件处理

### 发布事件
```csharp
public class BlogService : IBlogService
{
    private readonly IEventBus _eventBus;
    
    public async Task<CreatePostResult> CreatePostAsync(BlogPost post)
    {
        // 保存博客文章
        await _repository.AddAsync(post);
        
        // 发布事件
        await _eventBus.PublishAsync(new BlogPostCreatedEvent
        {
            PostId = post.Id,
            Title = post.Title,
            AuthorId = post.AuthorId,
            CreatedAt = post.CreatedAt
        });
        
        return new CreatePostResult { Success = true, PostId = post.Id };
    }
}
```

### 订阅事件
```csharp
public class BlogPlugin : IPlugin
{
    public async Task<bool> InitializeAsync(IPluginContext context)
    {
        // 订阅用户注册事件
        context.EventBus.Subscribe<UserRegisteredEvent>(async (eventData) =>
        {
            // 为新用户创建默认博客设置
            var blogService = context.GetService<IBlogService>();
            await blogService.CreateDefaultSettingsAsync(eventData.UserId);
        });
        
        // 订阅内容删除事件
        context.EventBus.Subscribe<ContentDeletedEvent>(async (eventData) =>
        {
            if (eventData.ContentType == "blog-post")
            {
                // 清理相关数据
                await CleanupBlogData(eventData.ContentId);
            }
        });
        
        return true;
    }
}
```

## 配置管理

### 插件配置
```csharp
public class BlogSettings
{
    public int MaxPostLength { get; set; } = 50000;
    public bool AllowComments { get; set; } = true;
    public bool ModerationEnabled { get; set; } = false;
    public string[] AllowedFileTypes { get; set; } = { "jpg", "png", "gif" };
}

public class BlogService : IBlogService
{
    private readonly BlogSettings _settings;
    
    public BlogService(IPluginConfiguration config)
    {
        _settings = config.GetSettings<BlogSettings>("blog-plugin");
    }
    
    public async Task<bool> ValidatePostAsync(BlogPost post)
    {
        if (post.Content.Length > _settings.MaxPostLength)
        {
            throw new ValidationException($"文章长度不能超过 {_settings.MaxPostLength} 字符");
        }
        
        return true;
    }
}
```

## 权限控制

### 权限检查
```csharp
[ApiController]
[Route("api/blog")]
public class BlogController : ControllerBase
{
    [HttpPost("posts")]
    [RequirePermission("blog.create")]
    public async Task<IActionResult> CreatePost([FromBody] CreatePostRequest request)
    {
        var blogService = HttpContext.RequestServices.GetRequiredService<IBlogService>();
        var result = await blogService.CreatePostAsync(request);
        return Ok(result);
    }
    
    [HttpPut("posts/{id}")]
    [RequirePermission("blog.edit")]
    public async Task<IActionResult> UpdatePost(int id, [FromBody] UpdatePostRequest request)
    {
        // 检查是否为文章作者或管理员
        if (!await IsAuthorOrAdmin(id))
        {
            return Forbid();
        }
        
        var blogService = HttpContext.RequestServices.GetRequiredService<IBlogService>();
        var result = await blogService.UpdatePostAsync(id, request);
        return Ok(result);
    }
}
```

## 测试

### 单元测试
```csharp
[TestClass]
public class BlogServiceTests
{
    private Mock<IBlogRepository> _mockRepository;
    private Mock<IEventBus> _mockEventBus;
    private BlogService _blogService;
    
    [TestInitialize]
    public void Setup()
    {
        _mockRepository = new Mock<IBlogRepository>();
        _mockEventBus = new Mock<IEventBus>();
        _blogService = new BlogService(_mockRepository.Object, _mockEventBus.Object);
    }
    
    [TestMethod]
    public async Task CreatePostAsync_ValidPost_ReturnsSuccess()
    {
        // Arrange
        var post = new BlogPost
        {
            Title = "测试文章",
            Content = "这是一篇测试文章",
            AuthorId = 1
        };
        
        _mockRepository.Setup(r => r.AddAsync(It.IsAny<BlogPost>()))
                      .Returns(Task.CompletedTask);
        
        // Act
        var result = await _blogService.CreatePostAsync(post);
        
        // Assert
        Assert.IsTrue(result.Success);
        _mockEventBus.Verify(e => e.PublishAsync(It.IsAny<BlogPostCreatedEvent>()), Times.Once);
    }
}
```

## 打包和发布

### 构建插件
```bash
# 构建插件
dotnet build --configuration Release

# 打包插件
dotnet pack --configuration Release --output ./packages
```

### 插件包结构
```
MyBlogPlugin.1.0.0.nupkg
├── lib/
│   └── net8.0/
│       ├── MyBlogPlugin.dll
│       └── MyBlogPlugin.pdb
├── content/
│   └── wwwroot/
│       ├── js/
│       ├── css/
│       └── images/
├── plugin.json
└── README.md
```

## 最佳实践

### 性能优化
- 使用异步方法处理IO操作
- 实现适当的缓存策略
- 避免在主线程执行耗时操作
- 使用分页查询大量数据

### 安全考虑
- 验证所有用户输入
- 使用参数化查询防止SQL注入
- 实现适当的权限检查
- 敏感数据加密存储

### 错误处理
- 使用结构化异常处理
- 记录详细的错误日志
- 提供友好的错误消息
- 实现优雅降级

### 代码质量
- 遵循SOLID原则
- 编写单元测试
- 使用依赖注入
- 保持代码简洁可读