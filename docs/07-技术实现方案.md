# VoxNest æŠ€æœ¯å®ç°æ–¹æ¡ˆ

## æ•´ä½“æŠ€æœ¯æ¶æ„

### ç³»ç»Ÿæ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯å±‚ (Frontend)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  React App  â”‚  Plugin UI  â”‚  Admin Panel  â”‚  Mobile App    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        ç½‘å…³å±‚ (Gateway)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  API Gateway  â”‚  Load Balancer  â”‚  Rate Limiter  â”‚  Auth   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        åº”ç”¨å±‚ (Application)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Core API  â”‚  Plugin Runtime  â”‚  Event Bus  â”‚  Job Queue   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        æ•°æ®å±‚ (Data)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PostgreSQL  â”‚  Redis  â”‚  Elasticsearch  â”‚  File Storage   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆé€‰æ‹©

#### å‰ç«¯æŠ€æœ¯æ ˆï¼ˆåŸºäºå®é™…é¡¹ç›®é…ç½®ï¼‰â­ å·²æ›´æ–°
- **æ¡†æ¶**: React 19 + TypeScript 5.0
- **æ„å»ºå·¥å…·**: Vite æœ€æ–°ç‰ˆæœ¬
- **UIç»„ä»¶åº“**: Ant Designï¼ˆä¼ä¸šçº§UIç»„ä»¶ï¼‰
- **çŠ¶æ€ç®¡ç†**: Zustandï¼ˆè½»é‡çŠ¶æ€ç®¡ç†ï¼Œåœ¨storesä¸­ä½¿ç”¨ï¼‰
- **APIæŸ¥è¯¢**: React Queryï¼ˆæ•°æ®è·å–å’Œç¼“å­˜ï¼‰
- **æ‰©å±•ç³»ç»Ÿ**: è‡ªç ” VoxNest Extension Framework
  - é›†æˆç³»ç»Ÿï¼ˆIntegration APIï¼‰
  - æ§½ä½ç®¡ç†ï¼ˆSlot Managerï¼‰ 
  - æ‰©å±•å‘ç°ä¸åŠ è½½ï¼ˆExtension Discovery & Loaderï¼‰
  - å†…ç½®é›†æˆï¼ˆReactã€Layoutã€Styleã€DevToolsã€Routerï¼‰
  - çƒ­é‡è½½ä¼˜åŒ–ï¼ˆé˜²æŠ–æœºåˆ¶ï¼Œé¿å…é¢‘ç¹é‡è½½ï¼‰
- **è·¯ç”±**: React Router v6ï¼ˆé€šè¿‡è·¯ç”±é›†æˆï¼‰
- **HTTPå®¢æˆ·ç«¯**: ç»Ÿä¸€çš„APIå®¢æˆ·ç«¯ï¼Œæ”¯æŒResult<T>å“åº”æ ¼å¼
- **æ ·å¼**: CSSå˜é‡ + ä¸»é¢˜ç³»ç»Ÿï¼Œæ”¯æŒæ·±è‰²æ¨¡å¼å’Œè‡ªå®šä¹‰ä¸»é¢˜

#### åç«¯æŠ€æœ¯æ ˆï¼ˆåŸºäºå®é™…é¡¹ç›®é…ç½®ï¼‰â­ å·²æ›´æ–°
- **æ¡†æ¶**: ASP.NET Core 9.0ï¼ˆ.NET 9ï¼‰
- **ORM**: Entity Framework Core 9.0
- **æ•°æ®åº“**: MySQL/PostgreSQL æ”¯æŒï¼Œä¼˜åŒ–è¿æ¥æ± é…ç½®
- **é…ç½®ç®¡ç†**: YAMLé…ç½®æ–‡ä»¶ + ç»Ÿä¸€é…ç½®API
- **APIæ–‡æ¡£**: Microsoft.AspNetCore.OpenApi 9.0.8
- **SPAé›†æˆ**: Microsoft.AspNetCore.SpaProxy
- **æ‰©å±•API**: è‡ªç ”æ‰©å±•æ–‡ä»¶æœåŠ¡API + é…ç½®ç®¡ç†API
  - `/api/extension/plugins/index` - æ’ä»¶ç´¢å¼•
  - `/api/extension/themes/index` - ä¸»é¢˜ç´¢å¼•
  - `/api/extension/files/{type}/{id}/{file}` - æ‰©å±•æ–‡ä»¶æœåŠ¡
  - `/api/server-config/*` - æœåŠ¡å™¨é…ç½®ç®¡ç†
  - `/api/install/*` - å®‰è£…å’Œåˆå§‹åŒ–
  - `/api/extension/{type}s/{id}/manifest` - æ¸…å•æ–‡ä»¶API
- **æ•°æ®åº“**: PostgreSQLï¼ˆä¸»æ•°æ®åº“ï¼‰+ MySQLï¼ˆå…¼å®¹æ”¯æŒï¼‰
- **ç¼“å­˜**: Redis 7.xï¼ˆé€šè¿‡æ’ä»¶æ‰©å±•ï¼‰
- **æœç´¢**: Elasticsearchï¼ˆé€šè¿‡æ’ä»¶æ‰©å±•ï¼‰
- **æ¶ˆæ¯é˜Ÿåˆ—**: åŸºäºå†…å­˜ + æ’ä»¶æ‰©å±•
- **æ–‡ä»¶å­˜å‚¨**: æœ¬åœ°å­˜å‚¨ + äº‘å­˜å‚¨ï¼ˆæ’ä»¶å®ç°ï¼‰
- **å®æ—¶é€šä¿¡**: SignalRï¼ˆé€šè¿‡æ’ä»¶æ‰©å±•ï¼‰

#### æ‰©å±•ç³»ç»Ÿæ¶æ„
- **å‰ç«¯æ‰©å±•æ¡†æ¶**: ç±» Astro Integration API è®¾è®¡
  - ç”Ÿå‘½å‘¨æœŸé’©å­ï¼šframework:readyã€components:readyã€app:startã€app:startedã€app:destroy
  - æ§½ä½ç³»ç»Ÿï¼šæ”¯æŒä¼˜å…ˆçº§ã€æ¡ä»¶æ¸²æŸ“ã€åŠ¨æ€æ³¨å†Œ
  - å†…ç½®é›†æˆï¼šReactã€å¸ƒå±€ã€æ ·å¼ã€å¼€å‘å·¥å…·ã€è·¯ç”±
- **æ‰©å±•å‘ç°æœºåˆ¶**: 
  - æ–‡ä»¶ç³»ç»Ÿæ‰«æï¼š`/public/extensions/{plugins|themes}/`
  - APIé©±åŠ¨å‘ç°ï¼šé€šè¿‡åç«¯APIè·å–å·²å®‰è£…æ‰©å±•
  - æ¸…å•éªŒè¯ï¼šExtensionManifestæ ¼å¼éªŒè¯
- **åŠ¨æ€åŠ è½½ç³»ç»Ÿ**:
  - æ ·å¼åŠ è½½ï¼šåŠ¨æ€ `<link>` æ ‡ç­¾
  - è„šæœ¬åŠ è½½ï¼šåŠ¨æ€ `<script>` æ ‡ç­¾
  - æ¨¡å—åŠ è½½ï¼šåŠ¨æ€ `import()` ESæ¨¡å—
  - ä¸»é¢˜å˜é‡ï¼šCSSå˜é‡åŠ¨æ€åº”ç”¨

#### åŸºç¡€è®¾æ–½
- **å®¹å™¨åŒ–**: Docker + Docker Compose
- **å¼€å‘å·¥å…·**: 
  - å¼€å‘æ¨¡å¼è°ƒè¯•ï¼š`Ctrl+Shift+D`ï¼ˆè°ƒè¯•é¢æ¿ï¼‰ã€`Ctrl+Shift+S`ï¼ˆçŠ¶æ€æŸ¥çœ‹ï¼‰
  - å…¨å±€è°ƒè¯•å¯¹è±¡ï¼š`window.__VOXNEST_FRAMEWORK__`ã€`window.__DEBUG__`
  - æ€§èƒ½ç›‘æ§ï¼šExtensionPerformanceMonitor
- **æµ‹è¯•æ¡†æ¶**: 
  - å•å…ƒæµ‹è¯•ï¼šJest + React Testing Library
  - æ‰©å±•æµ‹è¯•ï¼šè‡ªå®šä¹‰æµ‹è¯•å·¥å…·

## æ ¸å¿ƒæ¡†æ¶å®ç°

### é¡¹ç›®ç»“æ„è®¾è®¡
```
VoxNest/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ VoxNest.Core/                    # æ ¸å¿ƒæ¡†æ¶
â”‚   â”‚   â”œâ”€â”€ Entities/                    # å®ä½“æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ Interfaces/                  # æ ¸å¿ƒæ¥å£
â”‚   â”‚   â”œâ”€â”€ Services/                    # æ ¸å¿ƒæœåŠ¡
â”‚   â”‚   â”œâ”€â”€ Events/                      # é¢†åŸŸäº‹ä»¶
â”‚   â”‚   â””â”€â”€ Exceptions/                  # è‡ªå®šä¹‰å¼‚å¸¸
â”‚   â”‚
â”‚   â”œâ”€â”€ VoxNest.Infrastructure/          # åŸºç¡€è®¾æ–½
â”‚   â”‚   â”œâ”€â”€ Data/                        # æ•°æ®è®¿é—®
â”‚   â”‚   â”œâ”€â”€ Cache/                       # ç¼“å­˜å®ç°
â”‚   â”‚   â”œâ”€â”€ Storage/                     # æ–‡ä»¶å­˜å‚¨
â”‚   â”‚   â”œâ”€â”€ Messaging/                   # æ¶ˆæ¯é˜Ÿåˆ—
â”‚   â”‚   â””â”€â”€ External/                    # å¤–éƒ¨æœåŠ¡
â”‚   â”‚
â”‚   â”œâ”€â”€ VoxNest.Application/             # åº”ç”¨æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ Features/                    # åŠŸèƒ½æ¨¡å—
â”‚   â”‚   â”œâ”€â”€ DTOs/                        # æ•°æ®ä¼ è¾“å¯¹è±¡
â”‚   â”‚   â”œâ”€â”€ Mappings/                    # å¯¹è±¡æ˜ å°„
â”‚   â”‚   â””â”€â”€ Validators/                  # æ•°æ®éªŒè¯
â”‚   â”‚
â”‚   â”œâ”€â”€ VoxNest.Plugin/                  # æ’ä»¶æ¡†æ¶
â”‚   â”‚   â”œâ”€â”€ Abstractions/                # æ’ä»¶æŠ½è±¡
â”‚   â”‚   â”œâ”€â”€ Runtime/                     # æ’ä»¶è¿è¡Œæ—¶
â”‚   â”‚   â”œâ”€â”€ Management/                  # æ’ä»¶ç®¡ç†
â”‚   â”‚   â””â”€â”€ Security/                    # æ’ä»¶å®‰å…¨
â”‚   â”‚
â”‚   â”œâ”€â”€ VoxNest.API/                     # Web API
â”‚   â”‚   â”œâ”€â”€ Controllers/                 # APIæ§åˆ¶å™¨
â”‚   â”‚   â”œâ”€â”€ Middlewares/                 # ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ Filters/                     # è¿‡æ»¤å™¨
â”‚   â”‚   â””â”€â”€ Hubs/                        # SignalR Hub
â”‚   â”‚
â”‚   â””â”€â”€ VoxNest.Web/                     # å‰ç«¯åº”ç”¨
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ components/              # ç»„ä»¶
â”‚       â”‚   â”œâ”€â”€ pages/                   # é¡µé¢
â”‚       â”‚   â”œâ”€â”€ hooks/                   # è‡ªå®šä¹‰Hook
â”‚       â”‚   â”œâ”€â”€ stores/                  # çŠ¶æ€ç®¡ç†
â”‚       â”‚   â”œâ”€â”€ services/                # APIæœåŠ¡
â”‚       â”‚   â”œâ”€â”€ utils/                   # å·¥å…·å‡½æ•°
â”‚       â”‚   â””â”€â”€ types/                   # ç±»å‹å®šä¹‰
â”‚       â””â”€â”€ public/
â”‚
â”œâ”€â”€ plugins/                             # æ’ä»¶ç›®å½•
â”‚   â”œâ”€â”€ VoxNest.Blog/                    # åšå®¢æ’ä»¶
â”‚   â”œâ”€â”€ VoxNest.Forum/                   # è®ºå›æ’ä»¶
â”‚   â””â”€â”€ VoxNest.QA/                      # é—®ç­”æ’ä»¶
â”‚
â”œâ”€â”€ tests/                               # æµ‹è¯•
â”‚   â”œâ”€â”€ VoxNest.UnitTests/
â”‚   â”œâ”€â”€ VoxNest.IntegrationTests/
â”‚   â””â”€â”€ VoxNest.E2ETests/
â”‚
â”œâ”€â”€ docs/                                # æ–‡æ¡£
â”œâ”€â”€ scripts/                             # è„šæœ¬
â””â”€â”€ docker/                              # Dockeré…ç½®
```

### æ•°æ®åº“è®¾è®¡

#### æ ¸å¿ƒè¡¨ç»“æ„
```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    display_name VARCHAR(100),
    avatar_url VARCHAR(500),
    bio TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    is_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP
);

-- è§’è‰²è¡¨
CREATE TABLE roles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    is_system BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_roles_name (name)
);

-- ç”¨æˆ·è§’è‰²å…³è”è¡¨
CREATE TABLE user_roles (
    user_id INT NOT NULL,
    role_id INT NOT NULL,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by INT,
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (assigned_by) REFERENCES users(id) ON DELETE SET NULL
);

-- æƒé™è¡¨
CREATE TABLE permissions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    resource VARCHAR(50) NOT NULL,
    action VARCHAR(50) NOT NULL,
    description TEXT,
    
    INDEX idx_permissions_resource_action (resource, action)
);

-- è§’è‰²æƒé™å…³è”è¡¨
CREATE TABLE role_permissions (
    role_id INT NOT NULL,
    permission_id INT NOT NULL,
    PRIMARY KEY (role_id, permission_id),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
);

-- å†…å®¹è¡¨
CREATE TABLE contents (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(500) NOT NULL,
    slug VARCHAR(500) UNIQUE,
    body LONGTEXT,
    summary TEXT,
    content_type VARCHAR(50) NOT NULL,
    status TINYINT DEFAULT 0 COMMENT '0:è‰ç¨¿ 1:å·²å‘å¸ƒ 2:å·²å½’æ¡£ 3:å·²åˆ é™¤',
    author_id INT NOT NULL,
    view_count INT DEFAULT 0,
    like_count INT DEFAULT 0,
    comment_count INT DEFAULT 0,
    is_featured BOOLEAN DEFAULT FALSE,
    published_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_contents_type_status (content_type, status),
    INDEX idx_contents_author (author_id),
    INDEX idx_contents_published (published_at DESC),
    INDEX idx_contents_featured (is_featured, published_at DESC),
    FULLTEXT INDEX idx_contents_search (title, summary, body)
);

-- åˆ†ç±»è¡¨
CREATE TABLE categories (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    parent_id INT NULL,
    sort_order INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (parent_id) REFERENCES categories(id) ON DELETE SET NULL,
    INDEX idx_categories_parent (parent_id),
    INDEX idx_categories_slug (slug),
    INDEX idx_categories_active (is_active)
);

-- æ ‡ç­¾è¡¨
CREATE TABLE tags (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    slug VARCHAR(50) UNIQUE NOT NULL,
    color VARCHAR(7) DEFAULT '#1890ff',
    usage_count INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_tags_name (name),
    INDEX idx_tags_slug (slug),
    INDEX idx_tags_usage (usage_count DESC)
);

-- å†…å®¹åˆ†ç±»å…³è”è¡¨
CREATE TABLE content_categories (
    content_id INT NOT NULL,
    category_id INT NOT NULL,
    PRIMARY KEY (content_id, category_id),
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE,
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE
);

-- å†…å®¹æ ‡ç­¾å…³è”è¡¨
CREATE TABLE content_tags (
    content_id INT NOT NULL,
    tag_id INT NOT NULL,
    PRIMARY KEY (content_id, tag_id),
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

-- æ’ä»¶è¡¨
CREATE TABLE plugins (
    id VARCHAR(100) PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    version VARCHAR(20) NOT NULL,
    description TEXT,
    author VARCHAR(100),
    homepage VARCHAR(500),
    assembly_path VARCHAR(500),
    is_enabled BOOLEAN DEFAULT FALSE,
    is_system BOOLEAN DEFAULT FALSE,
    configuration JSON,
    installed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_plugins_enabled (is_enabled),
    INDEX idx_plugins_system (is_system)
);

-- ç³»ç»Ÿè®¾ç½®è¡¨
CREATE TABLE system_settings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    `key` VARCHAR(100) UNIQUE NOT NULL,
    `value` TEXT,
    `type` VARCHAR(20) DEFAULT 'string' COMMENT 'string, number, boolean, json',
    category VARCHAR(50) DEFAULT 'general',
    description TEXT,
    is_readonly BOOLEAN DEFAULT FALSE,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_settings_category (category),
    INDEX idx_settings_key (`key`)
);

-- ç”¨æˆ·è®¾ç½®è¡¨
CREATE TABLE user_settings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    `key` VARCHAR(100) NOT NULL,
    `value` TEXT,
    `type` VARCHAR(20) DEFAULT 'string',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_user_key (user_id, `key`),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_settings_key (`key`)
);
```

### APIè®¾è®¡è§„èŒƒ

#### RESTful APIè®¾è®¡
```
# ç”¨æˆ·ç®¡ç†
GET    /api/users                    # è·å–ç”¨æˆ·åˆ—è¡¨
GET    /api/users/{id}               # è·å–ç”¨æˆ·è¯¦æƒ…
POST   /api/users                    # åˆ›å»ºç”¨æˆ·
PUT    /api/users/{id}               # æ›´æ–°ç”¨æˆ·
DELETE /api/users/{id}               # åˆ é™¤ç”¨æˆ·

# è®¤è¯æˆæƒ
POST   /api/auth/login               # ç”¨æˆ·ç™»å½•
POST   /api/auth/logout              # ç”¨æˆ·ç™»å‡º
POST   /api/auth/register            # ç”¨æˆ·æ³¨å†Œ
POST   /api/auth/refresh             # åˆ·æ–°Token
GET    /api/auth/profile             # è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯

# å†…å®¹ç®¡ç†
GET    /api/contents                 # è·å–å†…å®¹åˆ—è¡¨
GET    /api/contents/{id}            # è·å–å†…å®¹è¯¦æƒ…
POST   /api/contents                 # åˆ›å»ºå†…å®¹
PUT    /api/contents/{id}            # æ›´æ–°å†…å®¹
DELETE /api/contents/{id}            # åˆ é™¤å†…å®¹

# æ’ä»¶ç®¡ç†
GET    /api/plugins                  # è·å–æ’ä»¶åˆ—è¡¨
GET    /api/plugins/{id}             # è·å–æ’ä»¶è¯¦æƒ…
POST   /api/plugins/{id}/enable      # å¯ç”¨æ’ä»¶
POST   /api/plugins/{id}/disable     # ç¦ç”¨æ’ä»¶
POST   /api/plugins/install          # å®‰è£…æ’ä»¶
DELETE /api/plugins/{id}             # å¸è½½æ’ä»¶
```

#### ç»Ÿä¸€å“åº”æ ¼å¼
```json
{
  "success": true,
  "code": 200,
  "message": "æ“ä½œæˆåŠŸ",
  "data": {
    // å“åº”æ•°æ®
  },
  "timestamp": "2024-01-01T00:00:00Z",
  "traceId": "abc123"
}
```

### æ’ä»¶ç³»ç»Ÿå®ç°

#### æ’ä»¶åŠ è½½æœºåˆ¶
```csharp
public class PluginLoader : IPluginLoader
{
    private readonly ILogger<PluginLoader> _logger;
    private readonly Dictionary<string, Assembly> _loadedAssemblies;
    private readonly Dictionary<string, AssemblyLoadContext> _loadContexts;

    public async Task<IPlugin> LoadPluginAsync(string pluginPath)
    {
        try
        {
            // 1. åˆ›å»ºç‹¬ç«‹çš„ç¨‹åºé›†åŠ è½½ä¸Šä¸‹æ–‡
            var loadContext = new PluginLoadContext(pluginPath);
            
            // 2. åŠ è½½æ’ä»¶ç¨‹åºé›†
            var assembly = loadContext.LoadFromAssemblyPath(pluginPath);
            
            // 3. æŸ¥æ‰¾æ’ä»¶ç±»å‹
            var pluginType = FindPluginType(assembly);
            if (pluginType == null)
            {
                throw new InvalidOperationException("æœªæ‰¾åˆ°æ’ä»¶å®ç°ç±»");
            }
            
            // 4. åˆ›å»ºæ’ä»¶å®ä¾‹
            var plugin = Activator.CreateInstance(pluginType) as IPlugin;
            
            // 5. ç¼“å­˜åŠ è½½ä¿¡æ¯
            _loadedAssemblies[plugin.Id] = assembly;
            _loadContexts[plugin.Id] = loadContext;
            
            return plugin;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "åŠ è½½æ’ä»¶å¤±è´¥: {PluginPath}", pluginPath);
            throw;
        }
    }

    public async Task<bool> UnloadPluginAsync(string pluginId)
    {
        if (_loadContexts.TryGetValue(pluginId, out var loadContext))
        {
            // å¸è½½ç¨‹åºé›†ä¸Šä¸‹æ–‡
            loadContext.Unload();
            
            // æ¸…ç†ç¼“å­˜
            _loadedAssemblies.Remove(pluginId);
            _loadContexts.Remove(pluginId);
            
            // å¼ºåˆ¶åƒåœ¾å›æ”¶
            GC.Collect();
            GC.WaitForPendingFinalizers();
            
            return true;
        }
        
        return false;
    }
}
```

#### æ’ä»¶è¿è¡Œæ—¶ç®¡ç†
```csharp
public class PluginRuntime : IPluginRuntime
{
    private readonly Dictionary<string, IPlugin> _activePlugins;
    private readonly IServiceProvider _serviceProvider;
    private readonly IEventBus _eventBus;

    public async Task<bool> StartPluginAsync(string pluginId)
    {
        if (!_activePlugins.TryGetValue(pluginId, out var plugin))
        {
            return false;
        }

        try
        {
            // åˆ›å»ºæ’ä»¶ä¸Šä¸‹æ–‡
            var context = new PluginContext
            {
                Services = _serviceProvider,
                EventBus = _eventBus,
                Configuration = GetPluginConfiguration(pluginId),
                Logger = CreatePluginLogger(pluginId)
            };

            // åˆå§‹åŒ–æ’ä»¶
            await plugin.InitializeAsync(context);
            
            // å¯åŠ¨æ’ä»¶
            await plugin.StartAsync();
            
            // å‘å¸ƒæ’ä»¶å¯åŠ¨äº‹ä»¶
            await _eventBus.PublishAsync(new PluginStartedEvent
            {
                PluginId = pluginId,
                StartedAt = DateTime.UtcNow
            });

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "å¯åŠ¨æ’ä»¶å¤±è´¥: {PluginId}", pluginId);
            return false;
        }
    }
}
```

### å‰ç«¯æ¶æ„å®ç°

#### æ‰©å±•æ¡†æ¶æ ¸å¿ƒå®ç°
```typescript
// src/extensions/core/ExtensionFramework.ts
import type { 
  ExtensionFramework, 
  VoxNestConfig, 
  IntegrationManager,
  SlotManager,
  Logger 
} from './types';
import { createSlotManager } from './SlotManager';
import { createIntegrationManager } from './IntegrationManager';
import { createLogger } from './Logger';
import { getBuiltinIntegrations } from '../integrations/builtin';

export class VoxNestExtensionFramework implements ExtensionFramework {
  status: 'initializing' | 'ready' | 'error' = 'initializing';
  config: VoxNestConfig;
  slots: SlotManager;
  integrations: IntegrationManager;
  logger: Logger;

  constructor(config: VoxNestConfig = {}) {
    this.config = {
      appName: 'VoxNest',
      appVersion: '1.0.0',
      logLevel: 'info',
      autoRegisterBuiltins: true,
      ...config
    };

    this.logger = createLogger(this.config.appName || 'VoxNest', this.config.logLevel);
    this.slots = createSlotManager(this.logger);
    this.integrations = createIntegrationManager(this.logger);
  }

  async initialize(config?: VoxNestConfig): Promise<void> {
    try {
      this.logger.info('Initializing VoxNest Extension Framework...');
      
      if (config) {
        this.config = { ...this.config, ...config };
      }

      // æ³¨å†Œå†…ç½®é›†æˆ
      if (this.config.autoRegisterBuiltins) {
        const builtinIntegrations = getBuiltinIntegrations();
        builtinIntegrations.forEach(integration => {
          this.register(integration);
        });
      }

      // æ‰§è¡Œæ¡†æ¶åˆå§‹åŒ–é’©å­
      await this.integrations.executeHook('framework:ready', {
        framework: this,
        config: this.config,
        logger: this.logger,
        slots: this.slots
      });

      // æ‰§è¡Œç»„ä»¶ç³»ç»Ÿå°±ç»ªé’©å­
      await this.integrations.executeHook('components:ready', {
        framework: this,
        config: this.config,
        logger: this.logger,
        slots: this.slots
      });

      this.status = 'ready';
      this.logger.info('VoxNest Extension Framework initialized successfully');

    } catch (error) {
      this.status = 'error';
      this.logger.error('Failed to initialize framework:', error);
      throw error;
    }
  }

  register(integration: Integration): void {
    this.integrations.register(integration);
    this.logger.debug(`Registered integration: ${integration.name}`);
  }

  async destroy(): Promise<void> {
    this.logger.info('Destroying VoxNest Extension Framework...');
    
    await this.integrations.executeHook('app:destroy', {
      framework: this,
      config: this.config,
      logger: this.logger,
      slots: this.slots
    });

    // æ¸…ç†èµ„æº
    this.slots.clear();
    this.integrations.clear();
    
    this.status = 'initializing';
    this.logger.info('Framework destroyed');
  }

  getStats(): any {
    return {
      status: this.status,
      integrationsCount: this.integrations.getAll().length,
      slotsCount: this.slots.getAllSlots().length,
      config: this.config
    };
  }
}

// å·¥å‚å‡½æ•°
export function createExtensionFramework(config?: VoxNestConfig): ExtensionFramework {
  return new VoxNestExtensionFramework(config);
}
```

#### æ§½ä½ç®¡ç†å™¨å®ç°
```typescript
// src/extensions/core/SlotManager.ts
import React from 'react';
import type { SlotManager, ComponentRegistration, Logger } from './types';

export class VoxNestSlotManager implements SlotManager {
  private slots = new Map<string, ComponentRegistration[]>();
  private logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger.createChild('SlotManager');
  }

  register(slotId: string, registration: ComponentRegistration): void {
    if (!this.slots.has(slotId)) {
      this.slots.set(slotId, []);
    }

    const components = this.slots.get(slotId)!;
    
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒæºçš„ç»„ä»¶
    const existingIndex = components.findIndex(
      comp => comp.source === registration.source && comp.name === registration.name
    );

    if (existingIndex >= 0) {
      components[existingIndex] = registration;
      this.logger.debug(`Updated component in slot ${slotId}: ${registration.name}`);
    } else {
      components.push(registration);
      this.logger.debug(`Registered component to slot ${slotId}: ${registration.name || 'unnamed'}`);
    }

    // æŒ‰ä¼˜å…ˆçº§æ’åº
    components.sort((a, b) => (b.priority || 0) - (a.priority || 0));
  }

  unregister(slotId: string, source: string): void {
    const components = this.slots.get(slotId);
    if (components) {
      const filtered = components.filter(comp => comp.source !== source);
      this.slots.set(slotId, filtered);
      this.logger.debug(`Unregistered components from slot ${slotId} by source: ${source}`);
    }
  }

  unregisterBySource(source: string): void {
    for (const [slotId] of this.slots) {
      this.unregister(slotId, source);
    }
    this.logger.debug(`Unregistered all components by source: ${source}`);
  }

  getComponents(slotId: string): ComponentRegistration[] {
    return this.slots.get(slotId) || [];
  }

  hasComponents(slotId: string): boolean {
    const components = this.slots.get(slotId);
    return components ? components.length > 0 : false;
  }

  render(slotId: string, props?: any): React.ReactNode {
    const components = this.getComponents(slotId);
    
    if (components.length === 0) {
      return null;
    }

    return React.createElement(
      React.Fragment,
      null,
      ...components
        .filter(comp => !comp.condition || comp.condition(props))
        .map((comp, index) =>
          React.createElement(comp.component, {
            key: `${comp.source}-${comp.name || index}`,
            ...comp.props,
            ...props
          })
        )
    );
  }

  clear(slotId?: string): void {
    if (slotId) {
      this.slots.delete(slotId);
    } else {
      this.slots.clear();
    }
  }

  getAllSlots(): string[] {
    return Array.from(this.slots.keys());
  }
}

export function createSlotManager(logger: Logger): SlotManager {
  return new VoxNestSlotManager(logger);
}
```

#### React æ§½ä½ç»„ä»¶å®ç°
```tsx
// src/extensions/react/Slot.tsx
import React from 'react';
import { useExtensionFramework } from './ExtensionProvider';
import type { SlotProps } from '../core/types';

export const Slot: React.FC<SlotProps> = ({
  id,
  props,
  fallback,
  className,
  style,
  wrapper = true,
}) => {
  const framework = useExtensionFramework();
  
  if (!framework) {
    console.warn(`Slot ${id}: Extension framework not available`);
    return fallback || null;
  }

  const hasComponents = framework.slots.hasComponents(id);
  
  if (!hasComponents) {
    return fallback || null;
  }

  const content = framework.slots.render(id, props);
  
  if (!wrapper) {
    return content;
  }

  return (
    <div
      data-slot={id}
      className={className}
      style={style}
    >
      {content}
    </div>
  );
};

// æ‰©å±• Provider ç»„ä»¶
export const ExtensionProvider: React.FC<ExtensionProviderProps> = ({
  children,
  config
}) => {
  const [framework, setFramework] = React.useState<ExtensionFramework | null>(null);
  const [ready, setReady] = React.useState(false);

  React.useEffect(() => {
    const initFramework = async () => {
      try {
        const fw = createExtensionFramework(config);
        await fw.initialize();
        
        // æ‰§è¡Œåº”ç”¨å¯åŠ¨é’©å­
        await fw.integrations.executeHook('app:start', {
          framework: fw,
          config: fw.config,
          logger: fw.logger,
          slots: fw.slots
        });
        
        setFramework(fw);
        setReady(true);
        
        // æ‰§è¡Œåº”ç”¨å¯åŠ¨å®Œæˆé’©å­
        await fw.integrations.executeHook('app:started', {
          framework: fw,
          config: fw.config,
          logger: fw.logger,
          slots: fw.slots
        });
        
      } catch (error) {
        console.error('Failed to initialize extension framework:', error);
      }
    };

    initFramework();

    return () => {
      if (framework) {
        framework.destroy();
      }
    };
  }, []);

  if (!ready || !framework) {
    return <div>Loading extensions...</div>;
  }

  return (
    <ExtensionContext.Provider value={framework}>
      {children}
    </ExtensionContext.Provider>
  );
};
```

#### çŠ¶æ€ç®¡ç†è®¾è®¡
```typescript
// stores/authStore.ts - åŸºäºå·²å®ç°çš„æ¶æ„
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
  id: number;
  username: string;
  email: string;
  avatar?: string;
  roles: string[];
}

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  refreshToken: () => Promise<void>;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      isAuthenticated: false,

      login: async (credentials) => {
        const response = await authApi.login(credentials);
        set({
          user: response.user,
          token: response.token,
          isAuthenticated: true
        });
      },

      logout: () => {
        set({
          user: null,
          token: null,
          isAuthenticated: false
        });
      },

      refreshToken: async () => {
        const { token } = get();
        if (!token) return;
        
        const response = await authApi.refreshToken(token);
        set({ token: response.token });
      }
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({ 
        token: state.token,
        user: state.user 
      })
    }
  )
);
```

#### æ‰©å±•å‘ç°å’ŒåŠ è½½å®ç°
```typescript
// src/extensions/manager/ExtensionDiscovery.ts - åŸºäºå®é™…å®ç°
export class ExtensionDiscovery {
  private logger: Logger;
  private extensionsBasePath: string;
  private cache = new Map<string, DiscoveredExtension>();

  constructor(logger: Logger, extensionsBasePath = '/extensions') {
    this.logger = logger.createChild('ExtensionDiscovery');
    this.extensionsBasePath = extensionsBasePath;
  }

  async discoverPlugins(): Promise<DiscoveredExtension[]> {
    try {
      this.logger.info('Discovering available plugins...');
      const plugins = await this.discoverExtensionsByType('plugin');
      this.logger.info(`Found ${plugins.length} plugins`);
      return plugins;
    } catch (error) {
      this.logger.error('Failed to discover plugins:', error);
      return [];
    }
  }

  async discoverThemes(): Promise<DiscoveredExtension[]> {
    try {
      this.logger.info('Discovering available themes...');
      const themes = await this.discoverExtensionsByType('theme');
      this.logger.info(`Found ${themes.length} themes`);
      return themes;
    } catch (error) {
      this.logger.error('Failed to discover themes:', error);
      return [];
    }
  }

  private async discoverExtensionsByType(type: 'plugin' | 'theme'): Promise<DiscoveredExtension[]> {
    const extensions: DiscoveredExtension[] = [];
    const typeDir = `${this.extensionsBasePath}/${type}s`;

    try {
      // ä»APIè·å–æ‰©å±•ç›®å½•åˆ—è¡¨
      const extensionDirs = await this.getInstalledExtensionsFromAPI(typeDir);
      
      for (const dirName of extensionDirs) {
        try {
          const manifest = await this.loadManifestFromAPI(type, dirName);
          
          if (manifest && manifest.type === type) {
            const extension: DiscoveredExtension = {
              manifest,
              basePath: `${typeDir}/${dirName}`,
              manifestPath: `/api/extension/${type}s/${dirName}/manifest`
            };
            
            extensions.push(extension);
            this.cache.set(manifest.id, extension);
            
            this.logger.debug(`Discovered ${type}: ${manifest.name} (${manifest.id})`);
          }
        } catch (error) {
          this.logger.warn(`Failed to load manifest for ${dirName}:`, error);
        }
      }
    } catch (error) {
      this.logger.debug(`Directory ${typeDir} not found or inaccessible`);
    }

    return extensions;
  }

  private async getInstalledExtensionsFromAPI(path: string): Promise<string[]> {
    try {
      const type = path.includes('plugins') ? 'plugins' : 'themes';
      const endpoint = `/api/extension/${type}/index`;
      
      const response = await fetch(endpoint);
      if (response.ok) {
        const data = await response.json();
        
        if (data.isSuccess && data.data.directories) {
          return data.data.directories;
        }
      }
    } catch (error) {
      this.logger.debug(`Failed to fetch installed extensions from API:`, error);
    }
    
    return [];
  }

  private async loadManifestFromAPI(type: 'plugin' | 'theme', extensionId: string): Promise<ExtensionManifest | null> {
    try {
      const endpoint = `/api/extension/${type}s/${extensionId}/manifest`;
      const response = await fetch(endpoint);
      
      if (!response.ok) {
        return null;
      }
      
      const data = await response.json();
      if (data.isSuccess && data.data) {
        const manifest = data.data;
        return this.validateManifest(manifest) ? manifest : null;
      }
      
      return null;
    } catch (error) {
      this.logger.debug(`Failed to load manifest from API for ${extensionId}:`, error);
      return null;
    }
  }

  private validateManifest(manifest: any): boolean {
    if (!manifest || typeof manifest !== 'object') {
      return false;
    }

    const required = ['id', 'name', 'version', 'author', 'type'];
    return required.every(field => manifest[field] && typeof manifest[field] === 'string');
  }
}

// src/extensions/manager/ExtensionLoader.ts - åŸºäºå®é™…å®ç°
export class ExtensionLoader {
  private logger: Logger;
  private framework: ExtensionFramework;
  private loadedExtensions = new Map<string, LoadedExtension>();

  constructor(framework: ExtensionFramework) {
    this.framework = framework;
    this.logger = framework.logger.createChild('ExtensionLoader');
  }

  async loadPlugin(extension: DiscoveredExtension): Promise<LoadedExtension> {
    const loadedExt: LoadedExtension = {
      manifest: extension.manifest,
      basePath: extension.basePath,
      status: LoadingStatus.Loading
    };

    this.loadedExtensions.set(extension.manifest.id, loadedExt);

    try {
      this.logger.info(`Loading plugin: ${extension.manifest.name}`);

      // åŠ è½½æ ·å¼æ–‡ä»¶
      if (extension.manifest.styles) {
        await this.loadStyles(extension.manifest.styles, extension.basePath);
      }

      // åŠ è½½è„šæœ¬æ–‡ä»¶
      if (extension.manifest.scripts) {
        await this.loadScripts(extension.manifest.scripts, extension.basePath);
      }

      // åŠ è½½ä¸»å…¥å£æ–‡ä»¶
      if (extension.manifest.entry) {
        const instance = await this.loadEntryModule(extension.manifest.entry, extension.basePath);
        loadedExt.instance = instance;

        // å¦‚æœæ˜¯ React ç»„ä»¶æˆ–é›†æˆï¼Œæ³¨å†Œåˆ°æ¡†æ¶
        if (instance && typeof instance === 'object') {
          await this.registerPluginToFramework(instance, extension.manifest);
        }
      }

      loadedExt.status = LoadingStatus.Loaded;
      loadedExt.loadedAt = new Date();
      
      this.logger.info(`Plugin loaded successfully: ${extension.manifest.name}`);
      return loadedExt;

    } catch (error) {
      this.logger.error(`Failed to load plugin ${extension.manifest.name}:`, error);
      loadedExt.status = LoadingStatus.Failed;
      loadedExt.error = error instanceof Error ? error : new Error('Unknown loading error');
      return loadedExt;
    }
  }

  async loadTheme(extension: DiscoveredExtension): Promise<LoadedExtension> {
    const loadedExt: LoadedExtension = {
      manifest: extension.manifest,
      basePath: extension.basePath,
      status: LoadingStatus.Loading
    };

    this.loadedExtensions.set(extension.manifest.id, loadedExt);

    try {
      this.logger.info(`Loading theme: ${extension.manifest.name}`);

      // åŠ è½½ä¸»é¢˜æ ·å¼
      if (extension.manifest.styles) {
        await this.loadStyles(extension.manifest.styles, extension.basePath);
      }

      // åº”ç”¨ä¸»é¢˜å˜é‡
      if (extension.manifest.config?.variables) {
        this.applyThemeVariables(extension.manifest.config.variables);
      }

      // åŠ è½½ä¸»é¢˜è„šæœ¬ï¼ˆå¦‚æœæœ‰ï¼‰
      if (extension.manifest.scripts) {
        await this.loadScripts(extension.manifest.scripts, extension.basePath);
      }

      loadedExt.status = LoadingStatus.Loaded;
      loadedExt.loadedAt = new Date();
      
      this.logger.info(`Theme loaded successfully: ${extension.manifest.name}`);
      return loadedExt;

    } catch (error) {
      this.logger.error(`Failed to load theme ${extension.manifest.name}:`, error);
      loadedExt.status = LoadingStatus.Failed;
      loadedExt.error = error instanceof Error ? error : new Error('Unknown loading error');
      return loadedExt;
    }
  }

  private async loadStyles(styles: string[], basePath: string): Promise<void> {
    const extensionId = basePath.split('/').pop();
    const type = basePath.includes('plugins') ? 'plugins' : 'themes';
    
    for (const stylePath of styles) {
      try {
        const apiPath = `/api/extension/files/${type}/${extensionId}/${stylePath}`;
        
        if (document.querySelector(`link[href="${apiPath}"]`)) {
          continue;
        }

        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = apiPath;
        link.type = 'text/css';

        document.head.appendChild(link);
        
        await new Promise<void>((resolve, reject) => {
          link.onload = () => resolve();
          link.onerror = () => reject(new Error(`Failed to load stylesheet: ${apiPath}`));
        });

        this.logger.debug(`Loaded stylesheet: ${apiPath}`);
      } catch (error) {
        this.logger.warn(`Failed to load stylesheet ${stylePath}:`, error);
      }
    }
  }

  private async loadEntryModule(entryPath: string, basePath: string): Promise<any> {
    const extensionId = basePath.split('/').pop();
    const type = basePath.includes('plugins') ? 'plugins' : 'themes';
    const apiPath = `/api/extension/files/${type}/${extensionId}/${entryPath}`;
    
    try {
      const module = await import(/* @vite-ignore */ apiPath);
      return module.default || module;
    } catch (error) {
      this.logger.error(`Failed to load entry module ${apiPath}:`, error);
      throw error;
    }
  }

  private async registerPluginToFramework(instance: any, manifest: ExtensionManifest): Promise<void> {
    try {
      if (instance.name && instance.hooks) {
        this.framework.register(instance);
        this.logger.debug(`Registered integration: ${instance.name}`);
        return;
      }

      if (typeof instance.register === 'function') {
        await instance.register(this.framework);
        this.logger.debug(`Executed plugin register function: ${manifest.name}`);
        return;
      }

      if (typeof instance === 'function' || React.isValidElement(instance)) {
        this.framework.slots.register('plugin.components', {
          component: instance,
          source: manifest.id,
          name: manifest.name,
          priority: 0
        });
        this.logger.debug(`Registered component to default slot: ${manifest.name}`);
        return;
      }

      this.logger.warn(`Unknown plugin format for: ${manifest.name}`);
    } catch (error) {
      this.logger.error(`Failed to register plugin ${manifest.name}:`, error);
      throw error;
    }
  }

  private applyThemeVariables(variables: Record<string, string>): void {
    const root = document.documentElement;
    
    for (const [name, value] of Object.entries(variables)) {
      const cssVarName = name.startsWith('--') ? name : `--${name}`;
      root.style.setProperty(cssVarName, value);
    }

    this.logger.debug('Applied theme variables:', variables);
  }
}
```

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### æ•°æ®åº“ä¼˜åŒ–
```sql
-- åˆ›å»ºç´¢å¼•
CREATE INDEX CONCURRENTLY idx_contents_type_status_published 
ON contents (content_type, status, published_at DESC);

CREATE INDEX CONCURRENTLY idx_contents_author_created 
ON contents (author_id, created_at DESC);

CREATE INDEX CONCURRENTLY idx_users_username_lower 
ON users (LOWER(username));

-- åˆ†åŒºè¡¨è®¾è®¡ï¼ˆæŒ‰æ—¶é—´åˆ†åŒºï¼‰
CREATE TABLE contents_2024 PARTITION OF contents
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- ç‰©åŒ–è§†å›¾ï¼ˆçƒ­é—¨å†…å®¹ï¼‰
CREATE MATERIALIZED VIEW popular_contents AS
SELECT 
    c.id,
    c.title,
    c.view_count,
    c.like_count,
    c.comment_count,
    (c.view_count * 0.3 + c.like_count * 0.5 + c.comment_count * 0.2) as popularity_score
FROM contents c
WHERE c.status = 1 
  AND c.published_at > NOW() - INTERVAL '30 days'
ORDER BY popularity_score DESC;

-- å®šæœŸåˆ·æ–°ç‰©åŒ–è§†å›¾
REFRESH MATERIALIZED VIEW CONCURRENTLY popular_contents;
```

#### ç¼“å­˜ç­–ç•¥
```csharp
public class CacheService : ICacheService
{
    private readonly IDistributedCache _distributedCache;
    private readonly IMemoryCache _memoryCache;

    // å¤šçº§ç¼“å­˜ç­–ç•¥
    public async Task<T> GetAsync<T>(string key)
    {
        // 1. å…ˆæŸ¥å†…å­˜ç¼“å­˜
        if (_memoryCache.TryGetValue(key, out T value))
        {
            return value;
        }

        // 2. æŸ¥åˆ†å¸ƒå¼ç¼“å­˜
        var cachedData = await _distributedCache.GetStringAsync(key);
        if (cachedData != null)
        {
            value = JsonSerializer.Deserialize<T>(cachedData);
            
            // å›å†™å†…å­˜ç¼“å­˜
            _memoryCache.Set(key, value, TimeSpan.FromMinutes(5));
            return value;
        }

        return default(T);
    }

    // ç¼“å­˜é¢„çƒ­
    public async Task WarmupCacheAsync()
    {
        var popularContents = await _contentService.GetPopularContentsAsync();
        foreach (var content in popularContents)
        {
            var key = $"content:{content.Id}";
            await SetAsync(key, content, TimeSpan.FromHours(1));
        }
    }
}
```

### å®‰å…¨å®ç°

#### JWTè®¤è¯å®ç°
```csharp
public class JwtService : IJwtService
{
    private readonly JwtSettings _jwtSettings;

    public string GenerateToken(User user)
    {
        var claims = new List<Claim>
        {
            new(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new(ClaimTypes.Name, user.Username),
            new(ClaimTypes.Email, user.Email),
            new("jti", Guid.NewGuid().ToString())
        };

        // æ·»åŠ è§’è‰²å£°æ˜
        foreach (var role in user.UserRoles)
        {
            claims.Add(new Claim(ClaimTypes.Role, role.Role.Name));
        }

        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));
        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var token = new JwtSecurityToken(
            issuer: _jwtSettings.Issuer,
            audience: _jwtSettings.Audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),
            signingCredentials: credentials
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}
```

#### æƒé™éªŒè¯ä¸­é—´ä»¶
```csharp
public class PermissionMiddleware
{
    private readonly RequestDelegate _next;

    public async Task InvokeAsync(HttpContext context)
    {
        var endpoint = context.GetEndpoint();
        var permissionAttribute = endpoint?.Metadata.GetMetadata<RequirePermissionAttribute>();
        
        if (permissionAttribute != null)
        {
            var user = context.User;
            if (!user.Identity.IsAuthenticated)
            {
                context.Response.StatusCode = 401;
                return;
            }

            var hasPermission = await CheckPermissionAsync(user, permissionAttribute.Permission);
            if (!hasPermission)
            {
                context.Response.StatusCode = 403;
                return;
            }
        }

        await _next(context);
    }
}
```

### éƒ¨ç½²æ–¹æ¡ˆ

#### Dockerå®¹å™¨åŒ–
```dockerfile
# Dockerfile.api
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ["VoxNest.API/VoxNest.API.csproj", "VoxNest.API/"]
RUN dotnet restore "VoxNest.API/VoxNest.API.csproj"
COPY . .
WORKDIR "/src/VoxNest.API"
RUN dotnet build "VoxNest.API.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "VoxNest.API.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "VoxNest.API.dll"]
```

#### Docker Composeé…ç½®
```yaml
version: '3.8'

services:
  voxnest-api:
    build:
      context: .
      dockerfile: Dockerfile.api
    ports:
      - "5000:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__DefaultConnection=Server=mysql;Database=voxnest;Uid=voxnest;Pwd=password;
      - ConnectionStrings__AnalyticsConnection=Host=postgres;Database=voxnest_analytics;Username=postgres;Password=password
      - Redis__ConnectionString=redis:6379
    depends_on:
      - mysql
      - postgres
      - redis
    networks:
      - voxnest-network

  voxnest-web:
    build:
      context: ./voxnest.client
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    environment:
      - REACT_APP_API_URL=http://localhost:5000
    networks:
      - voxnest-network

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=voxnest
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - voxnest-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - voxnest-network

  elasticsearch:
    image: elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    networks:
      - voxnest-network

volumes:
  postgres_data:
  redis_data:
  elasticsearch_data:

networks:
  voxnest-network:
    driver: bridge
```

#### Kuberneteséƒ¨ç½²
```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: voxnest-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: voxnest-api
  template:
    metadata:
      labels:
        app: voxnest-api
    spec:
      containers:
      - name: voxnest-api
        image: voxnest/api:latest
        ports:
        - containerPort: 80
        env:
        - name: ConnectionStrings__DefaultConnection
          valueFrom:
            secretKeyRef:
              name: voxnest-secrets
              key: database-connection
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: voxnest-api-service
spec:
  selector:
    app: voxnest-api
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer
```

### ç›‘æ§å’Œæ—¥å¿—

#### åº”ç”¨ç›‘æ§
```csharp
// å¥åº·æ£€æŸ¥
public void ConfigureServices(IServiceCollection services)
{
    services.AddHealthChecks()
        .AddDbContextCheck<VoxNestDbContext>()
        .AddRedis(Configuration.GetConnectionString("Redis"))
        .AddElasticsearch(Configuration.GetConnectionString("Elasticsearch"));
}

// æ€§èƒ½ç›‘æ§
public void Configure(IApplicationBuilder app)
{
    app.UseMiddleware<PerformanceMonitoringMiddleware>();
    app.UseHealthChecks("/health");
}
```

#### æ—¥å¿—é…ç½®
```json
{
  "Serilog": {
    "Using": ["Serilog.Sinks.Console", "Serilog.Sinks.Elasticsearch"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}"
        }
      },
      {
        "Name": "Elasticsearch",
        "Args": {
          "nodeUris": "http://elasticsearch:9200",
          "indexFormat": "voxnest-logs-{0:yyyy.MM.dd}"
        }
      }
    ]
  }
}
```

---

## ğŸš€ æœ€æ–°æŠ€æœ¯æ›´æ–°ä¸ä¼˜åŒ– â­ 2025å¹´9æœˆç‰ˆæœ¬

### æ ¸å¿ƒåŠŸèƒ½æ›´æ–°

#### 1. ç»Ÿä¸€é…ç½®ç®¡ç†ç³»ç»Ÿ
```typescript
// å‰åç«¯é…ç½®ç»Ÿä¸€ç®¡ç†
interface UnifiedConfig {
  frontend: FrontendSettings;
  backend: ServerConfig;
}

// å®æ—¶é…ç½®æ›´æ–°æœºåˆ¶
const updateConfig = async (config: Partial<ServerConfig>) => {
  const result = await serverConfigApi.updateServerConfig(config);
  if (result.isSuccess) {
    // é…ç½®ç«‹å³ç”Ÿæ•ˆï¼Œæ— éœ€é‡å¯
    message.success('é…ç½®æ›´æ–°æˆåŠŸ');
  }
};
```

#### 2. æ‰©å±•ç®¡ç†ç³»ç»Ÿä¼˜åŒ–
```typescript
// å®æ—¶çŠ¶æ€åé¦ˆ
const handleToggleExtension = useCallback(async (extension: Extension) => {
  // ç«‹å³æ›´æ–°UIçŠ¶æ€ï¼Œæä¾›å³æ—¶åé¦ˆ
  setExtensions(prev => prev.map(ext => 
    ext.uniqueId === extension.uniqueId 
      ? { ...ext, status: 'loading' }
      : ext
  ));
  
  try {
    const result = await api.toggleExtension(extension);
    if (result.isSuccess) {
      await loadExtensions(); // é‡æ–°åŠ è½½æœ€æ–°çŠ¶æ€
    } else {
      // æ“ä½œå¤±è´¥æ—¶æ¢å¤åŸçŠ¶æ€
      restoreExtensionState(extension);
    }
  } catch (error) {
    restoreExtensionState(extension);
  }
}, [loadExtensions]);
```

#### 3. æ—¶åŒºåŠŸèƒ½å®Œå–„
```csharp
// å…¨çƒæ—¶åŒºæ”¯æŒ
public class TimeZoneService : ITimeZoneService
{
    public async Task<IEnumerable<TimeZoneInfo>> GetAvailableTimeZonesAsync()
    {
        return TimeZoneInfo.GetSystemTimeZones()
            .Select(tz => new TimeZoneInfo
            {
                Id = tz.Id,
                DisplayName = tz.DisplayName,
                StandardName = tz.StandardName,
                BaseUtcOffset = tz.BaseUtcOffset.ToString()
            })
            .OrderBy(tz => tz.BaseUtcOffset)
            .ThenBy(tz => tz.DisplayName);
    }
    
    public async Task<bool> SetTimeZoneAsync(string timeZoneId)
    {
        // æ›´æ–° server-config.yml é…ç½®
        await _configService.UpdateServerConfigAsync(new ServerConfigDto 
        { 
            TimeZone = timeZoneId 
        });
        return true;
    }
}
```

### æ€§èƒ½ä¼˜åŒ–å®ç°

#### 1. çƒ­é‡è½½ç³»ç»Ÿä¼˜åŒ–
```typescript
class ExtensionHotReload {
  private reloadTimers = new Map<string, number>();
  
  constructor(config: HotReloadConfig) {
    this.config = {
      pollingInterval: 5000,    // é™ä½è½®è¯¢é¢‘ç‡
      debounceDelay: 2000,      // å¢åŠ é˜²æŠ–å»¶è¿Ÿ
      ...config
    };
  }
  
  // é˜²æŠ–æœºåˆ¶é¿å…é¢‘ç¹é‡è½½
  private scheduleExtensionReload(extensionId: string): void {
    const existingTimer = this.reloadTimers.get(extensionId);
    if (existingTimer) {
      window.clearTimeout(existingTimer);
    }
    
    const timer = window.setTimeout(async () => {
      this.reloadTimers.delete(extensionId);
      await this.reloadExtension(extensionId);
    }, this.config.debounceDelay);
    
    this.reloadTimers.set(extensionId, timer);
  }
}
```

#### 2. æ•°æ®åº“è¿æ¥ä¼˜åŒ–
```csharp
// MySQLè¿æ¥æ± ä¼˜åŒ–
services.AddDbContext<VoxNestDbContext>(options =>
{
    var connectionString = Configuration.GetConnectionString("DefaultConnection");
    var enhancedConnectionString = EnhanceConnectionString(connectionString);
    
    options.UseMySql(enhancedConnectionString, ServerVersion.AutoDetect(connectionString), opts =>
    {
        opts.CommandTimeout(60);
        opts.EnableRetryOnFailure(
            maxRetryCount: 3,
            maxRetryDelay: TimeSpan.FromSeconds(5),
            errorNumbersToAdd: null);
    });
});

private static string EnhanceConnectionString(string connectionString)
{
    var builder = new MySqlConnectionStringBuilder(connectionString)
    {
        Pooling = true,
        MinimumPoolSize = 5,
        MaximumPoolSize = 100,
        ConnectionTimeout = 30,
        DefaultCommandTimeout = 60,
        ConnectionLifeTime = 300
    };
    return builder.ConnectionString;
}
```

### å…³é”®Bugä¿®å¤

#### 1. Reactè¡¨æ ¼Keyé‡å¤é—®é¢˜
```typescript
// ä¿®å¤å‰ï¼šä½¿ç”¨å¯èƒ½é‡å¤çš„id
<Table rowKey="id" dataSource={extensions} />

// ä¿®å¤åï¼šä½¿ç”¨å”¯ä¸€çš„uniqueId
<Table rowKey="uniqueId" dataSource={extensions} />
```

#### 2. çƒ­é‡è½½æ— é™å¾ªç¯ä¿®å¤
```typescript
// é—®é¢˜æ ¹å› ï¼šé…ç½®æ–‡ä»¶å˜åŒ–è§¦å‘æ— é™é‡è½½
// è§£å†³æ–¹æ¡ˆï¼šç¦ç”¨é…ç½®æ–‡ä»¶ç›‘æ§ï¼Œåªç›‘æ§æ‰©å±•æºç 
private async checkConfigChanges(): Promise<void> {
  // æš‚æ—¶ç¦ç”¨é…ç½®æ–‡ä»¶å˜åŒ–ç›‘æ§ï¼Œé¿å…ä¸æ‰©å±•ç®¡ç†æ“ä½œå†²çª
  return; // ç›´æ¥è¿”å›ï¼Œä¸æ£€æŸ¥é…ç½®æ–‡ä»¶å˜åŒ–
}
```

#### 3. YAMLé…ç½®ååºåˆ—åŒ–ä¼˜åŒ–
```csharp
// ä¿®å¤å‰ï¼šåŠ¨æ€å±æ€§è®¿é—®å¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
var serverConfig = yamlConfig.Server; // è¿è¡Œæ—¶é”™è¯¯

// ä¿®å¤åï¼šå­—å…¸è®¿é—®æ¨¡å¼
private string GetStringValue(object section, string key, string defaultValue = "")
{
    if (section is Dictionary<object, object> dict && dict.TryGetValue(key, out var value))
    {
        return value?.ToString() ?? defaultValue;
    }
    return defaultValue;
}
```

### 2025å¹´9æœˆç‰ˆæœ¬æˆæœ
- âœ… **ç»Ÿä¸€é…ç½®ç®¡ç†** - å‰åç«¯é…ç½®ç»Ÿä¸€ç•Œé¢ï¼Œå®æ—¶æ›´æ–°
- âœ… **æ‰©å±•ç®¡ç†ä¼˜åŒ–** - å®æ—¶çŠ¶æ€åé¦ˆï¼Œç”¨æˆ·ä½“éªŒæ˜¾è‘—æå‡  
- âœ… **æ€§èƒ½ä¼˜åŒ–** - çƒ­é‡è½½é˜²æŠ–ã€æ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
- âœ… **Bugä¿®å¤** - è§£å†³å…³é”®ç¨³å®šæ€§é—®é¢˜ï¼Œæå‡ç³»ç»Ÿå¯é æ€§
- âœ… **ç•Œé¢æ”¹è¿›** - ç»Ÿä¸€è®¾è®¡è¯­è¨€ï¼Œç°ä»£åŒ–äº¤äº’ä½“éªŒ
- âœ… **æ—¶åŒºåŠŸèƒ½** - å®Œæ•´çš„å…¨çƒæ—¶åŒºæ”¯æŒï¼Œå›½é™…åŒ–å‡†å¤‡

---

è¿™ä¸ªæŠ€æœ¯å®ç°æ–¹æ¡ˆä¸ºVoxNesté¡¹ç›®æä¾›äº†å®Œæ•´çš„æŠ€æœ¯æ¶æ„æŒ‡å¯¼ï¼Œæ¶µç›–äº†ä»æ ¸å¿ƒæ¡†æ¶åˆ°éƒ¨ç½²è¿ç»´çš„å„ä¸ªæ–¹é¢ï¼Œç¡®ä¿é¡¹ç›®èƒ½å¤Ÿé«˜æ•ˆã€å®‰å…¨ã€å¯æ‰©å±•åœ°å®ç°ã€‚é¡¹ç›®å·²è¿›å…¥ç¨³å®šå‘å±•é˜¶æ®µï¼Œæ ¸å¿ƒæ¡†æ¶å’Œæ‰©å±•ç³»ç»Ÿæˆç†Ÿå¯ç”¨ï¼Œä¸ºåç»­çš„æ’ä»¶ç”Ÿæ€å»ºè®¾å¥ å®šäº†åšå®åŸºç¡€ã€‚