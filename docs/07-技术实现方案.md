# VoxNest 技术实现方案

## 整体技术架构

### 系统架构图
```
┌─────────────────────────────────────────────────────────────┐
│                        前端层 (Frontend)                    │
├─────────────────────────────────────────────────────────────┤
│  React App  │  Plugin UI  │  Admin Panel  │  Mobile App    │
├─────────────────────────────────────────────────────────────┤
│                        网关层 (Gateway)                     │
├─────────────────────────────────────────────────────────────┤
│  API Gateway  │  Load Balancer  │  Rate Limiter  │  Auth   │
├─────────────────────────────────────────────────────────────┤
│                        应用层 (Application)                 │
├─────────────────────────────────────────────────────────────┤
│  Core API  │  Plugin Runtime  │  Event Bus  │  Job Queue   │
├─────────────────────────────────────────────────────────────┤
│                        数据层 (Data)                        │
├─────────────────────────────────────────────────────────────┤
│  PostgreSQL  │  Redis  │  Elasticsearch  │  File Storage   │
└─────────────────────────────────────────────────────────────┘
```

### 技术栈选择

#### 前端技术栈（基于实际项目配置）
- **框架**: React 18.3.1 + TypeScript 5.8.3
- **构建工具**: Vite 6.0.2
- **开发工具**: ESLint 9.17.0 + TypeScript ESLint 8.18.1
- **状态管理**: Zustand（轻量状态管理，在stores中使用）
- **扩展系统**: 自研 VoxNest Extension Framework
  - 集成系统（Integration API）
  - 槽位管理（Slot Manager） 
  - 扩展发现与加载（Extension Discovery & Loader）
  - 内置集成（React、Layout、Style、DevTools、Router）
- **UI组件库**: 自行实现，基于CSS变量的主题系统
- **路由**: React Router v6（通过路由集成）
- **HTTP客户端**: 基于 Fetch API 的客户端封装
- **样式**: CSS变量 + 主题系统，支持深色模式

#### 后端技术栈（基于实际项目配置）
- **框架**: ASP.NET Core 9.0（.NET 9）
- **API文档**: Microsoft.AspNetCore.OpenApi 9.0.8
- **SPA集成**: Microsoft.AspNetCore.SpaProxy
- **扩展API**: 自研扩展文件服务API
  - `/api/extension/plugins/index` - 插件索引
  - `/api/extension/themes/index` - 主题索引
  - `/api/extension/files/{type}/{id}/{file}` - 扩展文件服务
  - `/api/extension/{type}s/{id}/manifest` - 清单文件API
- **数据库**: PostgreSQL（主数据库）+ MySQL（兼容支持）
- **缓存**: Redis 7.x（通过插件扩展）
- **搜索**: Elasticsearch（通过插件扩展）
- **消息队列**: 基于内存 + 插件扩展
- **文件存储**: 本地存储 + 云存储（插件实现）
- **实时通信**: SignalR（通过插件扩展）

#### 扩展系统架构
- **前端扩展框架**: 类 Astro Integration API 设计
  - 生命周期钩子：framework:ready、components:ready、app:start、app:started、app:destroy
  - 槽位系统：支持优先级、条件渲染、动态注册
  - 内置集成：React、布局、样式、开发工具、路由
- **扩展发现机制**: 
  - 文件系统扫描：`/public/extensions/{plugins|themes}/`
  - API驱动发现：通过后端API获取已安装扩展
  - 清单验证：ExtensionManifest格式验证
- **动态加载系统**:
  - 样式加载：动态 `<link>` 标签
  - 脚本加载：动态 `<script>` 标签
  - 模块加载：动态 `import()` ES模块
  - 主题变量：CSS变量动态应用

#### 基础设施
- **容器化**: Docker + Docker Compose
- **开发工具**: 
  - 开发模式调试：`Ctrl+Shift+D`（调试面板）、`Ctrl+Shift+S`（状态查看）
  - 全局调试对象：`window.__VOXNEST_FRAMEWORK__`、`window.__DEBUG__`
  - 性能监控：ExtensionPerformanceMonitor
- **测试框架**: 
  - 单元测试：Jest + React Testing Library
  - 扩展测试：自定义测试工具

## 核心框架实现

### 项目结构设计
```
VoxNest/
├── src/
│   ├── VoxNest.Core/                    # 核心框架
│   │   ├── Entities/                    # 实体模型
│   │   ├── Interfaces/                  # 核心接口
│   │   ├── Services/                    # 核心服务
│   │   ├── Events/                      # 领域事件
│   │   └── Exceptions/                  # 自定义异常
│   │
│   ├── VoxNest.Infrastructure/          # 基础设施
│   │   ├── Data/                        # 数据访问
│   │   ├── Cache/                       # 缓存实现
│   │   ├── Storage/                     # 文件存储
│   │   ├── Messaging/                   # 消息队列
│   │   └── External/                    # 外部服务
│   │
│   ├── VoxNest.Application/             # 应用服务
│   │   ├── Features/                    # 功能模块
│   │   ├── DTOs/                        # 数据传输对象
│   │   ├── Mappings/                    # 对象映射
│   │   └── Validators/                  # 数据验证
│   │
│   ├── VoxNest.Plugin/                  # 插件框架
│   │   ├── Abstractions/                # 插件抽象
│   │   ├── Runtime/                     # 插件运行时
│   │   ├── Management/                  # 插件管理
│   │   └── Security/                    # 插件安全
│   │
│   ├── VoxNest.API/                     # Web API
│   │   ├── Controllers/                 # API控制器
│   │   ├── Middlewares/                 # 中间件
│   │   ├── Filters/                     # 过滤器
│   │   └── Hubs/                        # SignalR Hub
│   │
│   └── VoxNest.Web/                     # 前端应用
│       ├── src/
│       │   ├── components/              # 组件
│       │   ├── pages/                   # 页面
│       │   ├── hooks/                   # 自定义Hook
│       │   ├── stores/                  # 状态管理
│       │   ├── services/                # API服务
│       │   ├── utils/                   # 工具函数
│       │   └── types/                   # 类型定义
│       └── public/
│
├── plugins/                             # 插件目录
│   ├── VoxNest.Blog/                    # 博客插件
│   ├── VoxNest.Forum/                   # 论坛插件
│   └── VoxNest.QA/                      # 问答插件
│
├── tests/                               # 测试
│   ├── VoxNest.UnitTests/
│   ├── VoxNest.IntegrationTests/
│   └── VoxNest.E2ETests/
│
├── docs/                                # 文档
├── scripts/                             # 脚本
└── docker/                              # Docker配置
```

### 数据库设计

#### 核心表结构
```sql
-- 用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    display_name VARCHAR(100),
    avatar_url VARCHAR(500),
    bio TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    is_verified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login_at TIMESTAMP
);

-- 角色表
CREATE TABLE roles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    is_system BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_roles_name (name)
);

-- 用户角色关联表
CREATE TABLE user_roles (
    user_id INT NOT NULL,
    role_id INT NOT NULL,
    assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    assigned_by INT,
    PRIMARY KEY (user_id, role_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (assigned_by) REFERENCES users(id) ON DELETE SET NULL
);

-- 权限表
CREATE TABLE permissions (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    resource VARCHAR(50) NOT NULL,
    action VARCHAR(50) NOT NULL,
    description TEXT,
    
    INDEX idx_permissions_resource_action (resource, action)
);

-- 角色权限关联表
CREATE TABLE role_permissions (
    role_id INT NOT NULL,
    permission_id INT NOT NULL,
    PRIMARY KEY (role_id, permission_id),
    FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
);

-- 内容表
CREATE TABLE contents (
    id INT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(500) NOT NULL,
    slug VARCHAR(500) UNIQUE,
    body LONGTEXT,
    summary TEXT,
    content_type VARCHAR(50) NOT NULL,
    status TINYINT DEFAULT 0 COMMENT '0:草稿 1:已发布 2:已归档 3:已删除',
    author_id INT NOT NULL,
    view_count INT DEFAULT 0,
    like_count INT DEFAULT 0,
    comment_count INT DEFAULT 0,
    is_featured BOOLEAN DEFAULT FALSE,
    published_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (author_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_contents_type_status (content_type, status),
    INDEX idx_contents_author (author_id),
    INDEX idx_contents_published (published_at DESC),
    INDEX idx_contents_featured (is_featured, published_at DESC),
    FULLTEXT INDEX idx_contents_search (title, summary, body)
);

-- 分类表
CREATE TABLE categories (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    parent_id INT NULL,
    sort_order INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (parent_id) REFERENCES categories(id) ON DELETE SET NULL,
    INDEX idx_categories_parent (parent_id),
    INDEX idx_categories_slug (slug),
    INDEX idx_categories_active (is_active)
);

-- 标签表
CREATE TABLE tags (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    slug VARCHAR(50) UNIQUE NOT NULL,
    color VARCHAR(7) DEFAULT '#1890ff',
    usage_count INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_tags_name (name),
    INDEX idx_tags_slug (slug),
    INDEX idx_tags_usage (usage_count DESC)
);

-- 内容分类关联表
CREATE TABLE content_categories (
    content_id INT NOT NULL,
    category_id INT NOT NULL,
    PRIMARY KEY (content_id, category_id),
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE,
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE
);

-- 内容标签关联表
CREATE TABLE content_tags (
    content_id INT NOT NULL,
    tag_id INT NOT NULL,
    PRIMARY KEY (content_id, tag_id),
    FOREIGN KEY (content_id) REFERENCES contents(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

-- 插件表
CREATE TABLE plugins (
    id VARCHAR(100) PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    version VARCHAR(20) NOT NULL,
    description TEXT,
    author VARCHAR(100),
    homepage VARCHAR(500),
    assembly_path VARCHAR(500),
    is_enabled BOOLEAN DEFAULT FALSE,
    is_system BOOLEAN DEFAULT FALSE,
    configuration JSON,
    installed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_plugins_enabled (is_enabled),
    INDEX idx_plugins_system (is_system)
);

-- 系统设置表
CREATE TABLE system_settings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    `key` VARCHAR(100) UNIQUE NOT NULL,
    `value` TEXT,
    `type` VARCHAR(20) DEFAULT 'string' COMMENT 'string, number, boolean, json',
    category VARCHAR(50) DEFAULT 'general',
    description TEXT,
    is_readonly BOOLEAN DEFAULT FALSE,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_settings_category (category),
    INDEX idx_settings_key (`key`)
);

-- 用户设置表
CREATE TABLE user_settings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT NOT NULL,
    `key` VARCHAR(100) NOT NULL,
    `value` TEXT,
    `type` VARCHAR(20) DEFAULT 'string',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    UNIQUE KEY uk_user_key (user_id, `key`),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    INDEX idx_user_settings_key (`key`)
);
```

### API设计规范

#### RESTful API设计
```
# 用户管理
GET    /api/users                    # 获取用户列表
GET    /api/users/{id}               # 获取用户详情
POST   /api/users                    # 创建用户
PUT    /api/users/{id}               # 更新用户
DELETE /api/users/{id}               # 删除用户

# 认证授权
POST   /api/auth/login               # 用户登录
POST   /api/auth/logout              # 用户登出
POST   /api/auth/register            # 用户注册
POST   /api/auth/refresh             # 刷新Token
GET    /api/auth/profile             # 获取当前用户信息

# 内容管理
GET    /api/contents                 # 获取内容列表
GET    /api/contents/{id}            # 获取内容详情
POST   /api/contents                 # 创建内容
PUT    /api/contents/{id}            # 更新内容
DELETE /api/contents/{id}            # 删除内容

# 插件管理
GET    /api/plugins                  # 获取插件列表
GET    /api/plugins/{id}             # 获取插件详情
POST   /api/plugins/{id}/enable      # 启用插件
POST   /api/plugins/{id}/disable     # 禁用插件
POST   /api/plugins/install          # 安装插件
DELETE /api/plugins/{id}             # 卸载插件
```

#### 统一响应格式
```json
{
  "success": true,
  "code": 200,
  "message": "操作成功",
  "data": {
    // 响应数据
  },
  "timestamp": "2024-01-01T00:00:00Z",
  "traceId": "abc123"
}
```

### 插件系统实现

#### 插件加载机制
```csharp
public class PluginLoader : IPluginLoader
{
    private readonly ILogger<PluginLoader> _logger;
    private readonly Dictionary<string, Assembly> _loadedAssemblies;
    private readonly Dictionary<string, AssemblyLoadContext> _loadContexts;

    public async Task<IPlugin> LoadPluginAsync(string pluginPath)
    {
        try
        {
            // 1. 创建独立的程序集加载上下文
            var loadContext = new PluginLoadContext(pluginPath);
            
            // 2. 加载插件程序集
            var assembly = loadContext.LoadFromAssemblyPath(pluginPath);
            
            // 3. 查找插件类型
            var pluginType = FindPluginType(assembly);
            if (pluginType == null)
            {
                throw new InvalidOperationException("未找到插件实现类");
            }
            
            // 4. 创建插件实例
            var plugin = Activator.CreateInstance(pluginType) as IPlugin;
            
            // 5. 缓存加载信息
            _loadedAssemblies[plugin.Id] = assembly;
            _loadContexts[plugin.Id] = loadContext;
            
            return plugin;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "加载插件失败: {PluginPath}", pluginPath);
            throw;
        }
    }

    public async Task<bool> UnloadPluginAsync(string pluginId)
    {
        if (_loadContexts.TryGetValue(pluginId, out var loadContext))
        {
            // 卸载程序集上下文
            loadContext.Unload();
            
            // 清理缓存
            _loadedAssemblies.Remove(pluginId);
            _loadContexts.Remove(pluginId);
            
            // 强制垃圾回收
            GC.Collect();
            GC.WaitForPendingFinalizers();
            
            return true;
        }
        
        return false;
    }
}
```

#### 插件运行时管理
```csharp
public class PluginRuntime : IPluginRuntime
{
    private readonly Dictionary<string, IPlugin> _activePlugins;
    private readonly IServiceProvider _serviceProvider;
    private readonly IEventBus _eventBus;

    public async Task<bool> StartPluginAsync(string pluginId)
    {
        if (!_activePlugins.TryGetValue(pluginId, out var plugin))
        {
            return false;
        }

        try
        {
            // 创建插件上下文
            var context = new PluginContext
            {
                Services = _serviceProvider,
                EventBus = _eventBus,
                Configuration = GetPluginConfiguration(pluginId),
                Logger = CreatePluginLogger(pluginId)
            };

            // 初始化插件
            await plugin.InitializeAsync(context);
            
            // 启动插件
            await plugin.StartAsync();
            
            // 发布插件启动事件
            await _eventBus.PublishAsync(new PluginStartedEvent
            {
                PluginId = pluginId,
                StartedAt = DateTime.UtcNow
            });

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "启动插件失败: {PluginId}", pluginId);
            return false;
        }
    }
}
```

### 前端架构实现

#### 扩展框架核心实现
```typescript
// src/extensions/core/ExtensionFramework.ts
import type { 
  ExtensionFramework, 
  VoxNestConfig, 
  IntegrationManager,
  SlotManager,
  Logger 
} from './types';
import { createSlotManager } from './SlotManager';
import { createIntegrationManager } from './IntegrationManager';
import { createLogger } from './Logger';
import { getBuiltinIntegrations } from '../integrations/builtin';

export class VoxNestExtensionFramework implements ExtensionFramework {
  status: 'initializing' | 'ready' | 'error' = 'initializing';
  config: VoxNestConfig;
  slots: SlotManager;
  integrations: IntegrationManager;
  logger: Logger;

  constructor(config: VoxNestConfig = {}) {
    this.config = {
      appName: 'VoxNest',
      appVersion: '1.0.0',
      logLevel: 'info',
      autoRegisterBuiltins: true,
      ...config
    };

    this.logger = createLogger(this.config.appName || 'VoxNest', this.config.logLevel);
    this.slots = createSlotManager(this.logger);
    this.integrations = createIntegrationManager(this.logger);
  }

  async initialize(config?: VoxNestConfig): Promise<void> {
    try {
      this.logger.info('Initializing VoxNest Extension Framework...');
      
      if (config) {
        this.config = { ...this.config, ...config };
      }

      // 注册内置集成
      if (this.config.autoRegisterBuiltins) {
        const builtinIntegrations = getBuiltinIntegrations();
        builtinIntegrations.forEach(integration => {
          this.register(integration);
        });
      }

      // 执行框架初始化钩子
      await this.integrations.executeHook('framework:ready', {
        framework: this,
        config: this.config,
        logger: this.logger,
        slots: this.slots
      });

      // 执行组件系统就绪钩子
      await this.integrations.executeHook('components:ready', {
        framework: this,
        config: this.config,
        logger: this.logger,
        slots: this.slots
      });

      this.status = 'ready';
      this.logger.info('VoxNest Extension Framework initialized successfully');

    } catch (error) {
      this.status = 'error';
      this.logger.error('Failed to initialize framework:', error);
      throw error;
    }
  }

  register(integration: Integration): void {
    this.integrations.register(integration);
    this.logger.debug(`Registered integration: ${integration.name}`);
  }

  async destroy(): Promise<void> {
    this.logger.info('Destroying VoxNest Extension Framework...');
    
    await this.integrations.executeHook('app:destroy', {
      framework: this,
      config: this.config,
      logger: this.logger,
      slots: this.slots
    });

    // 清理资源
    this.slots.clear();
    this.integrations.clear();
    
    this.status = 'initializing';
    this.logger.info('Framework destroyed');
  }

  getStats(): any {
    return {
      status: this.status,
      integrationsCount: this.integrations.getAll().length,
      slotsCount: this.slots.getAllSlots().length,
      config: this.config
    };
  }
}

// 工厂函数
export function createExtensionFramework(config?: VoxNestConfig): ExtensionFramework {
  return new VoxNestExtensionFramework(config);
}
```

#### 槽位管理器实现
```typescript
// src/extensions/core/SlotManager.ts
import React from 'react';
import type { SlotManager, ComponentRegistration, Logger } from './types';

export class VoxNestSlotManager implements SlotManager {
  private slots = new Map<string, ComponentRegistration[]>();
  private logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger.createChild('SlotManager');
  }

  register(slotId: string, registration: ComponentRegistration): void {
    if (!this.slots.has(slotId)) {
      this.slots.set(slotId, []);
    }

    const components = this.slots.get(slotId)!;
    
    // 检查是否已存在相同源的组件
    const existingIndex = components.findIndex(
      comp => comp.source === registration.source && comp.name === registration.name
    );

    if (existingIndex >= 0) {
      components[existingIndex] = registration;
      this.logger.debug(`Updated component in slot ${slotId}: ${registration.name}`);
    } else {
      components.push(registration);
      this.logger.debug(`Registered component to slot ${slotId}: ${registration.name || 'unnamed'}`);
    }

    // 按优先级排序
    components.sort((a, b) => (b.priority || 0) - (a.priority || 0));
  }

  unregister(slotId: string, source: string): void {
    const components = this.slots.get(slotId);
    if (components) {
      const filtered = components.filter(comp => comp.source !== source);
      this.slots.set(slotId, filtered);
      this.logger.debug(`Unregistered components from slot ${slotId} by source: ${source}`);
    }
  }

  unregisterBySource(source: string): void {
    for (const [slotId] of this.slots) {
      this.unregister(slotId, source);
    }
    this.logger.debug(`Unregistered all components by source: ${source}`);
  }

  getComponents(slotId: string): ComponentRegistration[] {
    return this.slots.get(slotId) || [];
  }

  hasComponents(slotId: string): boolean {
    const components = this.slots.get(slotId);
    return components ? components.length > 0 : false;
  }

  render(slotId: string, props?: any): React.ReactNode {
    const components = this.getComponents(slotId);
    
    if (components.length === 0) {
      return null;
    }

    return React.createElement(
      React.Fragment,
      null,
      ...components
        .filter(comp => !comp.condition || comp.condition(props))
        .map((comp, index) =>
          React.createElement(comp.component, {
            key: `${comp.source}-${comp.name || index}`,
            ...comp.props,
            ...props
          })
        )
    );
  }

  clear(slotId?: string): void {
    if (slotId) {
      this.slots.delete(slotId);
    } else {
      this.slots.clear();
    }
  }

  getAllSlots(): string[] {
    return Array.from(this.slots.keys());
  }
}

export function createSlotManager(logger: Logger): SlotManager {
  return new VoxNestSlotManager(logger);
}
```

#### React 槽位组件实现
```tsx
// src/extensions/react/Slot.tsx
import React from 'react';
import { useExtensionFramework } from './ExtensionProvider';
import type { SlotProps } from '../core/types';

export const Slot: React.FC<SlotProps> = ({
  id,
  props,
  fallback,
  className,
  style,
  wrapper = true,
}) => {
  const framework = useExtensionFramework();
  
  if (!framework) {
    console.warn(`Slot ${id}: Extension framework not available`);
    return fallback || null;
  }

  const hasComponents = framework.slots.hasComponents(id);
  
  if (!hasComponents) {
    return fallback || null;
  }

  const content = framework.slots.render(id, props);
  
  if (!wrapper) {
    return content;
  }

  return (
    <div
      data-slot={id}
      className={className}
      style={style}
    >
      {content}
    </div>
  );
};

// 扩展 Provider 组件
export const ExtensionProvider: React.FC<ExtensionProviderProps> = ({
  children,
  config
}) => {
  const [framework, setFramework] = React.useState<ExtensionFramework | null>(null);
  const [ready, setReady] = React.useState(false);

  React.useEffect(() => {
    const initFramework = async () => {
      try {
        const fw = createExtensionFramework(config);
        await fw.initialize();
        
        // 执行应用启动钩子
        await fw.integrations.executeHook('app:start', {
          framework: fw,
          config: fw.config,
          logger: fw.logger,
          slots: fw.slots
        });
        
        setFramework(fw);
        setReady(true);
        
        // 执行应用启动完成钩子
        await fw.integrations.executeHook('app:started', {
          framework: fw,
          config: fw.config,
          logger: fw.logger,
          slots: fw.slots
        });
        
      } catch (error) {
        console.error('Failed to initialize extension framework:', error);
      }
    };

    initFramework();

    return () => {
      if (framework) {
        framework.destroy();
      }
    };
  }, []);

  if (!ready || !framework) {
    return <div>Loading extensions...</div>;
  }

  return (
    <ExtensionContext.Provider value={framework}>
      {children}
    </ExtensionContext.Provider>
  );
};
```

#### 状态管理设计
```typescript
// stores/authStore.ts - 基于已实现的架构
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
  id: number;
  username: string;
  email: string;
  avatar?: string;
  roles: string[];
}

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => void;
  refreshToken: () => Promise<void>;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      isAuthenticated: false,

      login: async (credentials) => {
        const response = await authApi.login(credentials);
        set({
          user: response.user,
          token: response.token,
          isAuthenticated: true
        });
      },

      logout: () => {
        set({
          user: null,
          token: null,
          isAuthenticated: false
        });
      },

      refreshToken: async () => {
        const { token } = get();
        if (!token) return;
        
        const response = await authApi.refreshToken(token);
        set({ token: response.token });
      }
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({ 
        token: state.token,
        user: state.user 
      })
    }
  )
);
```

#### 扩展发现和加载实现
```typescript
// src/extensions/manager/ExtensionDiscovery.ts - 基于实际实现
export class ExtensionDiscovery {
  private logger: Logger;
  private extensionsBasePath: string;
  private cache = new Map<string, DiscoveredExtension>();

  constructor(logger: Logger, extensionsBasePath = '/extensions') {
    this.logger = logger.createChild('ExtensionDiscovery');
    this.extensionsBasePath = extensionsBasePath;
  }

  async discoverPlugins(): Promise<DiscoveredExtension[]> {
    try {
      this.logger.info('Discovering available plugins...');
      const plugins = await this.discoverExtensionsByType('plugin');
      this.logger.info(`Found ${plugins.length} plugins`);
      return plugins;
    } catch (error) {
      this.logger.error('Failed to discover plugins:', error);
      return [];
    }
  }

  async discoverThemes(): Promise<DiscoveredExtension[]> {
    try {
      this.logger.info('Discovering available themes...');
      const themes = await this.discoverExtensionsByType('theme');
      this.logger.info(`Found ${themes.length} themes`);
      return themes;
    } catch (error) {
      this.logger.error('Failed to discover themes:', error);
      return [];
    }
  }

  private async discoverExtensionsByType(type: 'plugin' | 'theme'): Promise<DiscoveredExtension[]> {
    const extensions: DiscoveredExtension[] = [];
    const typeDir = `${this.extensionsBasePath}/${type}s`;

    try {
      // 从API获取扩展目录列表
      const extensionDirs = await this.getInstalledExtensionsFromAPI(typeDir);
      
      for (const dirName of extensionDirs) {
        try {
          const manifest = await this.loadManifestFromAPI(type, dirName);
          
          if (manifest && manifest.type === type) {
            const extension: DiscoveredExtension = {
              manifest,
              basePath: `${typeDir}/${dirName}`,
              manifestPath: `/api/extension/${type}s/${dirName}/manifest`
            };
            
            extensions.push(extension);
            this.cache.set(manifest.id, extension);
            
            this.logger.debug(`Discovered ${type}: ${manifest.name} (${manifest.id})`);
          }
        } catch (error) {
          this.logger.warn(`Failed to load manifest for ${dirName}:`, error);
        }
      }
    } catch (error) {
      this.logger.debug(`Directory ${typeDir} not found or inaccessible`);
    }

    return extensions;
  }

  private async getInstalledExtensionsFromAPI(path: string): Promise<string[]> {
    try {
      const type = path.includes('plugins') ? 'plugins' : 'themes';
      const endpoint = `/api/extension/${type}/index`;
      
      const response = await fetch(endpoint);
      if (response.ok) {
        const data = await response.json();
        
        if (data.isSuccess && data.data.directories) {
          return data.data.directories;
        }
      }
    } catch (error) {
      this.logger.debug(`Failed to fetch installed extensions from API:`, error);
    }
    
    return [];
  }

  private async loadManifestFromAPI(type: 'plugin' | 'theme', extensionId: string): Promise<ExtensionManifest | null> {
    try {
      const endpoint = `/api/extension/${type}s/${extensionId}/manifest`;
      const response = await fetch(endpoint);
      
      if (!response.ok) {
        return null;
      }
      
      const data = await response.json();
      if (data.isSuccess && data.data) {
        const manifest = data.data;
        return this.validateManifest(manifest) ? manifest : null;
      }
      
      return null;
    } catch (error) {
      this.logger.debug(`Failed to load manifest from API for ${extensionId}:`, error);
      return null;
    }
  }

  private validateManifest(manifest: any): boolean {
    if (!manifest || typeof manifest !== 'object') {
      return false;
    }

    const required = ['id', 'name', 'version', 'author', 'type'];
    return required.every(field => manifest[field] && typeof manifest[field] === 'string');
  }
}

// src/extensions/manager/ExtensionLoader.ts - 基于实际实现
export class ExtensionLoader {
  private logger: Logger;
  private framework: ExtensionFramework;
  private loadedExtensions = new Map<string, LoadedExtension>();

  constructor(framework: ExtensionFramework) {
    this.framework = framework;
    this.logger = framework.logger.createChild('ExtensionLoader');
  }

  async loadPlugin(extension: DiscoveredExtension): Promise<LoadedExtension> {
    const loadedExt: LoadedExtension = {
      manifest: extension.manifest,
      basePath: extension.basePath,
      status: LoadingStatus.Loading
    };

    this.loadedExtensions.set(extension.manifest.id, loadedExt);

    try {
      this.logger.info(`Loading plugin: ${extension.manifest.name}`);

      // 加载样式文件
      if (extension.manifest.styles) {
        await this.loadStyles(extension.manifest.styles, extension.basePath);
      }

      // 加载脚本文件
      if (extension.manifest.scripts) {
        await this.loadScripts(extension.manifest.scripts, extension.basePath);
      }

      // 加载主入口文件
      if (extension.manifest.entry) {
        const instance = await this.loadEntryModule(extension.manifest.entry, extension.basePath);
        loadedExt.instance = instance;

        // 如果是 React 组件或集成，注册到框架
        if (instance && typeof instance === 'object') {
          await this.registerPluginToFramework(instance, extension.manifest);
        }
      }

      loadedExt.status = LoadingStatus.Loaded;
      loadedExt.loadedAt = new Date();
      
      this.logger.info(`Plugin loaded successfully: ${extension.manifest.name}`);
      return loadedExt;

    } catch (error) {
      this.logger.error(`Failed to load plugin ${extension.manifest.name}:`, error);
      loadedExt.status = LoadingStatus.Failed;
      loadedExt.error = error instanceof Error ? error : new Error('Unknown loading error');
      return loadedExt;
    }
  }

  async loadTheme(extension: DiscoveredExtension): Promise<LoadedExtension> {
    const loadedExt: LoadedExtension = {
      manifest: extension.manifest,
      basePath: extension.basePath,
      status: LoadingStatus.Loading
    };

    this.loadedExtensions.set(extension.manifest.id, loadedExt);

    try {
      this.logger.info(`Loading theme: ${extension.manifest.name}`);

      // 加载主题样式
      if (extension.manifest.styles) {
        await this.loadStyles(extension.manifest.styles, extension.basePath);
      }

      // 应用主题变量
      if (extension.manifest.config?.variables) {
        this.applyThemeVariables(extension.manifest.config.variables);
      }

      // 加载主题脚本（如果有）
      if (extension.manifest.scripts) {
        await this.loadScripts(extension.manifest.scripts, extension.basePath);
      }

      loadedExt.status = LoadingStatus.Loaded;
      loadedExt.loadedAt = new Date();
      
      this.logger.info(`Theme loaded successfully: ${extension.manifest.name}`);
      return loadedExt;

    } catch (error) {
      this.logger.error(`Failed to load theme ${extension.manifest.name}:`, error);
      loadedExt.status = LoadingStatus.Failed;
      loadedExt.error = error instanceof Error ? error : new Error('Unknown loading error');
      return loadedExt;
    }
  }

  private async loadStyles(styles: string[], basePath: string): Promise<void> {
    const extensionId = basePath.split('/').pop();
    const type = basePath.includes('plugins') ? 'plugins' : 'themes';
    
    for (const stylePath of styles) {
      try {
        const apiPath = `/api/extension/files/${type}/${extensionId}/${stylePath}`;
        
        if (document.querySelector(`link[href="${apiPath}"]`)) {
          continue;
        }

        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = apiPath;
        link.type = 'text/css';

        document.head.appendChild(link);
        
        await new Promise<void>((resolve, reject) => {
          link.onload = () => resolve();
          link.onerror = () => reject(new Error(`Failed to load stylesheet: ${apiPath}`));
        });

        this.logger.debug(`Loaded stylesheet: ${apiPath}`);
      } catch (error) {
        this.logger.warn(`Failed to load stylesheet ${stylePath}:`, error);
      }
    }
  }

  private async loadEntryModule(entryPath: string, basePath: string): Promise<any> {
    const extensionId = basePath.split('/').pop();
    const type = basePath.includes('plugins') ? 'plugins' : 'themes';
    const apiPath = `/api/extension/files/${type}/${extensionId}/${entryPath}`;
    
    try {
      const module = await import(/* @vite-ignore */ apiPath);
      return module.default || module;
    } catch (error) {
      this.logger.error(`Failed to load entry module ${apiPath}:`, error);
      throw error;
    }
  }

  private async registerPluginToFramework(instance: any, manifest: ExtensionManifest): Promise<void> {
    try {
      if (instance.name && instance.hooks) {
        this.framework.register(instance);
        this.logger.debug(`Registered integration: ${instance.name}`);
        return;
      }

      if (typeof instance.register === 'function') {
        await instance.register(this.framework);
        this.logger.debug(`Executed plugin register function: ${manifest.name}`);
        return;
      }

      if (typeof instance === 'function' || React.isValidElement(instance)) {
        this.framework.slots.register('plugin.components', {
          component: instance,
          source: manifest.id,
          name: manifest.name,
          priority: 0
        });
        this.logger.debug(`Registered component to default slot: ${manifest.name}`);
        return;
      }

      this.logger.warn(`Unknown plugin format for: ${manifest.name}`);
    } catch (error) {
      this.logger.error(`Failed to register plugin ${manifest.name}:`, error);
      throw error;
    }
  }

  private applyThemeVariables(variables: Record<string, string>): void {
    const root = document.documentElement;
    
    for (const [name, value] of Object.entries(variables)) {
      const cssVarName = name.startsWith('--') ? name : `--${name}`;
      root.style.setProperty(cssVarName, value);
    }

    this.logger.debug('Applied theme variables:', variables);
  }
}
```

### 性能优化策略

#### 数据库优化
```sql
-- 创建索引
CREATE INDEX CONCURRENTLY idx_contents_type_status_published 
ON contents (content_type, status, published_at DESC);

CREATE INDEX CONCURRENTLY idx_contents_author_created 
ON contents (author_id, created_at DESC);

CREATE INDEX CONCURRENTLY idx_users_username_lower 
ON users (LOWER(username));

-- 分区表设计（按时间分区）
CREATE TABLE contents_2024 PARTITION OF contents
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- 物化视图（热门内容）
CREATE MATERIALIZED VIEW popular_contents AS
SELECT 
    c.id,
    c.title,
    c.view_count,
    c.like_count,
    c.comment_count,
    (c.view_count * 0.3 + c.like_count * 0.5 + c.comment_count * 0.2) as popularity_score
FROM contents c
WHERE c.status = 1 
  AND c.published_at > NOW() - INTERVAL '30 days'
ORDER BY popularity_score DESC;

-- 定期刷新物化视图
REFRESH MATERIALIZED VIEW CONCURRENTLY popular_contents;
```

#### 缓存策略
```csharp
public class CacheService : ICacheService
{
    private readonly IDistributedCache _distributedCache;
    private readonly IMemoryCache _memoryCache;

    // 多级缓存策略
    public async Task<T> GetAsync<T>(string key)
    {
        // 1. 先查内存缓存
        if (_memoryCache.TryGetValue(key, out T value))
        {
            return value;
        }

        // 2. 查分布式缓存
        var cachedData = await _distributedCache.GetStringAsync(key);
        if (cachedData != null)
        {
            value = JsonSerializer.Deserialize<T>(cachedData);
            
            // 回写内存缓存
            _memoryCache.Set(key, value, TimeSpan.FromMinutes(5));
            return value;
        }

        return default(T);
    }

    // 缓存预热
    public async Task WarmupCacheAsync()
    {
        var popularContents = await _contentService.GetPopularContentsAsync();
        foreach (var content in popularContents)
        {
            var key = $"content:{content.Id}";
            await SetAsync(key, content, TimeSpan.FromHours(1));
        }
    }
}
```

### 安全实现

#### JWT认证实现
```csharp
public class JwtService : IJwtService
{
    private readonly JwtSettings _jwtSettings;

    public string GenerateToken(User user)
    {
        var claims = new List<Claim>
        {
            new(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new(ClaimTypes.Name, user.Username),
            new(ClaimTypes.Email, user.Email),
            new("jti", Guid.NewGuid().ToString())
        };

        // 添加角色声明
        foreach (var role in user.UserRoles)
        {
            claims.Add(new Claim(ClaimTypes.Role, role.Role.Name));
        }

        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));
        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var token = new JwtSecurityToken(
            issuer: _jwtSettings.Issuer,
            audience: _jwtSettings.Audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(_jwtSettings.ExpirationMinutes),
            signingCredentials: credentials
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }
}
```

#### 权限验证中间件
```csharp
public class PermissionMiddleware
{
    private readonly RequestDelegate _next;

    public async Task InvokeAsync(HttpContext context)
    {
        var endpoint = context.GetEndpoint();
        var permissionAttribute = endpoint?.Metadata.GetMetadata<RequirePermissionAttribute>();
        
        if (permissionAttribute != null)
        {
            var user = context.User;
            if (!user.Identity.IsAuthenticated)
            {
                context.Response.StatusCode = 401;
                return;
            }

            var hasPermission = await CheckPermissionAsync(user, permissionAttribute.Permission);
            if (!hasPermission)
            {
                context.Response.StatusCode = 403;
                return;
            }
        }

        await _next(context);
    }
}
```

### 部署方案

#### Docker容器化
```dockerfile
# Dockerfile.api
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src
COPY ["VoxNest.API/VoxNest.API.csproj", "VoxNest.API/"]
RUN dotnet restore "VoxNest.API/VoxNest.API.csproj"
COPY . .
WORKDIR "/src/VoxNest.API"
RUN dotnet build "VoxNest.API.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "VoxNest.API.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "VoxNest.API.dll"]
```

#### Docker Compose配置
```yaml
version: '3.8'

services:
  voxnest-api:
    build:
      context: .
      dockerfile: Dockerfile.api
    ports:
      - "5000:80"
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
      - ConnectionStrings__DefaultConnection=Server=mysql;Database=voxnest;Uid=voxnest;Pwd=password;
      - ConnectionStrings__AnalyticsConnection=Host=postgres;Database=voxnest_analytics;Username=postgres;Password=password
      - Redis__ConnectionString=redis:6379
    depends_on:
      - mysql
      - postgres
      - redis
    networks:
      - voxnest-network

  voxnest-web:
    build:
      context: ./voxnest.client
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    environment:
      - REACT_APP_API_URL=http://localhost:5000
    networks:
      - voxnest-network

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=voxnest
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - voxnest-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - voxnest-network

  elasticsearch:
    image: elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
    networks:
      - voxnest-network

volumes:
  postgres_data:
  redis_data:
  elasticsearch_data:

networks:
  voxnest-network:
    driver: bridge
```

#### Kubernetes部署
```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: voxnest-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: voxnest-api
  template:
    metadata:
      labels:
        app: voxnest-api
    spec:
      containers:
      - name: voxnest-api
        image: voxnest/api:latest
        ports:
        - containerPort: 80
        env:
        - name: ConnectionStrings__DefaultConnection
          valueFrom:
            secretKeyRef:
              name: voxnest-secrets
              key: database-connection
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: voxnest-api-service
spec:
  selector:
    app: voxnest-api
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer
```

### 监控和日志

#### 应用监控
```csharp
// 健康检查
public void ConfigureServices(IServiceCollection services)
{
    services.AddHealthChecks()
        .AddDbContextCheck<VoxNestDbContext>()
        .AddRedis(Configuration.GetConnectionString("Redis"))
        .AddElasticsearch(Configuration.GetConnectionString("Elasticsearch"));
}

// 性能监控
public void Configure(IApplicationBuilder app)
{
    app.UseMiddleware<PerformanceMonitoringMiddleware>();
    app.UseHealthChecks("/health");
}
```

#### 日志配置
```json
{
  "Serilog": {
    "Using": ["Serilog.Sinks.Console", "Serilog.Sinks.Elasticsearch"],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}"
        }
      },
      {
        "Name": "Elasticsearch",
        "Args": {
          "nodeUris": "http://elasticsearch:9200",
          "indexFormat": "voxnest-logs-{0:yyyy.MM.dd}"
        }
      }
    ]
  }
}
```

这个技术实现方案为VoxNest项目提供了完整的技术架构指导，涵盖了从核心框架到部署运维的各个方面，确保项目能够高效、安全、可扩展地实现。